/*
 *  GeoBatch - Open Source geospatial batch processing system
 *  http://geobatch.geo-solutions.it/
 *  Copyright (C) 2013 GeoSolutions S.A.S.
 *  http://www.geo-solutions.it
 *
 *  GPLv3 + Classpath exception
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.geosolutions.geobatch.destination.vulnerability;

import it.geosolutions.geobatch.destination.ingestion.MetadataIngestionHandler;
import it.geosolutions.geobatch.destination.vulnerability.TargetManager.TargetInfo;
import it.geosolutions.geobatch.flow.event.ProgressListenerForwarder;

import java.awt.image.RenderedImage;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.Map;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

import javax.media.jai.JAI;

import org.geotools.filter.function.RangedClassifier;
import org.geotools.geometry.Envelope2D;
import org.geotools.jdbc.JDBCDataStore;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Utility class used for launching parallel vulnerability computations
 * 
 */
public class VulnerabilityEnvironment {

    /** Maximum queue dimension */
    private static final int MAXIMUM_QUEUE_SIZE = 1000000;

    /** Logger object */
    private final static Logger LOGGER = LoggerFactory.getLogger(VulnerabilityEnvironment.class);

    /** Waiting time until each idle thread is destroyed */
    private static final long TIMEOUT = 60;

    /** Latch used for handling the input threads */
    private CountDownLatch latch;

    /** ListenerForwarder passed in input */
    private ProgressListenerForwarder listenerForwarder;

    private AtomicBoolean threadFailure = new AtomicBoolean(false);

    public VulnerabilityEnvironment(ProgressListenerForwarder listenerForwarder) {
        this.listenerForwarder = listenerForwarder;
    }

    /**
     * This method calculated the vulnerability on for the levels 1 and 2.
     * 
     * The images are divided into Nx*Ny blocks and, for each block, vulnerability is calculated inside a thread.
     * 
     * @param closePhase
     * @param numXBlocks
     * @param numYBlocks
     * @param inputFeature
     * @param dataStore
     * @param metadataHandler
     * @param images
     * @param bandPerTargetNH
     * @param bandPerTargetH
     * @param writeMode
     * @param aggregationLevel
     * @param skipArcs
     * @param xStart
     * @param yStart
     * @param idStart
     * @throws Exception
     */
    public void computeLevel12(String closePhase, int numXBlocks, int numYBlocks,
            String inputFeature, JDBCDataStore dataStore, MetadataIngestionHandler metadataHandler,
            RenderedImage[] images, Map<Integer, TargetInfo> bandPerTargetNH,
            Map<Integer, TargetInfo> bandPerTargetH, String writeMode, int aggregationLevel,
            boolean skipArcs, Integer[] xStartArray, Integer[] yStartArray, Integer[] xStopArray,
            Integer[] yStopArray, String idStart, Envelope2D bbox) throws Exception {

        // Optional removal of the features
        removeFeatures(metadataHandler, inputFeature, dataStore, aggregationLevel, writeMode);

        // Block division variables
        int minTileX = images[1].getMinTileX();
        int minTileY = images[1].getMinTileY();

        int maxTileX = minTileX + images[1].getNumXTiles();
        int maxTileY = minTileY + images[1].getNumYTiles();

        int calcWidth = images[1].getNumXTiles() / numXBlocks + 1;
        int calcHeight = images[1].getNumYTiles() / numXBlocks + 1;

        // Max Thread Number
        int threadMaxNumber = numXBlocks * numYBlocks;
        ThreadPoolExecutor executor = new ThreadPoolExecutor(threadMaxNumber, threadMaxNumber,
                TIMEOUT, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(MAXIMUM_QUEUE_SIZE));

        // Setting of the JAI thread number at least equal to the total thread number + 1 (if not already set)
        int parallelism = JAI.getDefaultInstance().getTileScheduler().getParallelism();
        if (parallelism < threadMaxNumber + 1) {
            JAI.getDefaultInstance().getTileScheduler().setParallelism(threadMaxNumber + 1);
        }

        // Counter used for the eventual xStartArray and yStartArray
        int count = 0;

        // Set used for avoiding to calculate the same arc
        ConcurrentSkipListSet<BigDecimal> set = new ConcurrentSkipListSet<BigDecimal>();
        // Latch initialization
        latch = new CountDownLatch(threadMaxNumber);

        // NOT HUMAN TARGETS

        int maxX = 0;
        int maxY = 0;

        String targetID = "NotHuman";

        // Cycle on the NotHuman Targets
        boolean arrayXPresent = xStartArray != null;
        boolean arrayYPresent = yStartArray != null;

        for (int x = minTileX; x < maxTileX; x += calcWidth) {
            maxX = x + calcWidth;
            if (maxX > maxTileX) {
                maxX = maxTileX;
            }
            for (int y = minTileY; y < maxTileY; y += calcHeight) {

                maxY = y + calcHeight;
                if (maxY > maxTileY) {
                    maxY = maxTileY;
                }
                // New vulnerability computation object used only inside this
                // thread
                VulnerabilityComputation vulnerability = new VulnerabilityComputation(inputFeature,
                        listenerForwarder, metadataHandler, dataStore);
                // Checks if the arrays are present
                Integer xStart = arrayXPresent ? xStartArray[count] : null;
                Integer yStart = arrayYPresent ? yStartArray[count] : null;

                Integer xStop = arrayXPresent ? xStopArray[count] : null;
                Integer yStop = arrayYPresent ? yStopArray[count] : null;
                // Thread which executes calculations
                MyRunnable run = new MyRunnable(vulnerability, aggregationLevel, writeMode,
                        closePhase, images[1], bandPerTargetNH, set, targetID, x, maxX, y, maxY,
                        skipArcs, xStart, yStart, xStop, yStop, idStart, bbox);

                executor.execute(run);
                // Counter Update
                count++;
            }
        }

        // Waiting the end of the operations of each thread
        latch.await();
        // Executor termination
        executor.shutdown();

        executor.awaitTermination(TIMEOUT, TimeUnit.SECONDS);
        // Check if any thread reports a failure
        if (threadFailure.get()) {
            throw new IllegalStateException("Error on calculating vulnerability");
        }

        // HUMAN TARGETS
        // Reset of the initial set
        set.clear();
        // Counter used for the eventual xStartArray and yStartArray
        count = 0;
        // Creation of a new ThreadPoolExecutor
        executor = new ThreadPoolExecutor(threadMaxNumber, threadMaxNumber, TIMEOUT,
                TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(MAXIMUM_QUEUE_SIZE));
        // Setting of the target to calculate to human
        targetID = "Human";
        // Creation of a new CountDownLatch
        latch = new CountDownLatch(threadMaxNumber);
        // Cycle on the Blocks
        for (int x = minTileX; x < maxTileX; x += calcWidth) {
            maxX = x + calcWidth;
            if (maxX > maxTileX) {
                maxX = maxTileX;
            }
            for (int y = minTileY; y < maxTileY; y += calcHeight) {
                maxY = y + calcHeight;
                if (maxY > maxTileY) {
                    maxY = maxTileY;
                }
                // Checks if the arrays are present
                Integer xStart = arrayXPresent ? xStartArray[count] : null;
                Integer yStart = arrayYPresent ? yStartArray[count] : null;

                Integer xStop = arrayXPresent ? xStopArray[count] : null;
                Integer yStop = arrayYPresent ? yStopArray[count] : null;

                VulnerabilityComputation vulnerability = new VulnerabilityComputation(inputFeature,
                        listenerForwarder, metadataHandler, dataStore);

                MyRunnable run = new MyRunnable(vulnerability, aggregationLevel, writeMode,
                        closePhase, images[0], bandPerTargetH, set, targetID, x, maxX, y, maxY,
                        skipArcs, xStart, yStart, xStop, yStop, idStart, bbox);

                executor.execute(run);

                // Counter Update
                count++;
            }
        }
        // Waiting the end of the operations of each thread
        latch.await();
        // Executor termination
        executor.shutdown();

        executor.awaitTermination(TIMEOUT, TimeUnit.SECONDS);
        // Check if any thread reports a failure
        if (threadFailure.get()) {
            throw new IllegalStateException("Error on calculating vulnerability");
        }
    }

    /**
     * This method optionally removes the existent features in order to insert new records
     * 
     * @param metadataHandler
     * @param inputFeature
     * @param dataStore
     * @param aggregationLevel
     * @param writeMode
     * @throws IOException
     */
    private void removeFeatures(MetadataIngestionHandler metadataHandler, String inputFeature,
            JDBCDataStore dataStore, int aggregationLevel, String writeMode) throws IOException {
        // Instantiation of a new vulnerability computation
        VulnerabilityComputation vulnerability = new VulnerabilityComputation(inputFeature,
                listenerForwarder, metadataHandler, dataStore);
        vulnerability.removeFeatures(writeMode, aggregationLevel);
    }

    /**
     * This method calculated the vulnerability on for the level 3.
     * 
     * Division of the input cells into N groups, and on each group the vulnerability is calculated with a Thread
     * 
     * 
     * @param closePhase
     * @param threadMaxNumber
     * @param groups
     * @param inputFeature
     * @param dataStore
     * @param metadataHandler
     * @param images
     * @param bandPerTargetNH
     * @param bandPerTargetH
     * @param writeMode
     * @param skipArcs
     * @param xStart
     * @param yStart
     * @throws Exception
     */
    public void computeLevel3(String closePhase, int threadMaxNumber, RangedClassifier groups,
            String inputFeature, JDBCDataStore dataStore, MetadataIngestionHandler metadataHandler,
            RenderedImage[] images, Map<Integer, TargetInfo> bandPerTargetNH,
            Map<Integer, TargetInfo> bandPerTargetH, String writeMode, boolean skipArcs,
            Envelope2D bbox) throws Exception {

        // Optional removal of the features associated to the
        removeFeatures(metadataHandler, inputFeature, dataStore, 3, writeMode);

        // Executor for handling N concurrent threads
        ThreadPoolExecutor executor = new ThreadPoolExecutor(threadMaxNumber, threadMaxNumber, 60,
                TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1000000));

        // Setting of the JAI thread number at least equal to the total thread number + 1 (if not already set)
        int parallelism = JAI.getDefaultInstance().getTileScheduler().getParallelism();
        if (parallelism < threadMaxNumber + 1) {
            JAI.getDefaultInstance().getTileScheduler().setParallelism(threadMaxNumber + 1);
        }

        // Set used for avoiding to calculate the same cell
        ConcurrentSkipListSet<BigDecimal> set = new ConcurrentSkipListSet<BigDecimal>();

        latch = new CountDownLatch(threadMaxNumber);
        // Not human target string
        String targetID = "NotHuman";
        // The only one aggregation level to calculate
        int aggregationLevel = 3;

        // Cycle on all the Cell groups
        for (int i = 0; i < threadMaxNumber; i++) {
            Double min = (Double) groups.getMin(i);
            Double max = (Double) groups.getMax(i);

            VulnerabilityComputation vulnerability = new VulnerabilityComputation(inputFeature,
                    listenerForwarder, metadataHandler, dataStore);
            // Setting of the Id bounds for the calculation
            vulnerability.setStartOriginId(min.longValue());
            vulnerability.setEndOriginId(max.longValue());

            MyRunnable run = new MyRunnable(vulnerability, aggregationLevel, writeMode, closePhase,
                    images[1], bandPerTargetNH, set, targetID, 0, 0, 0, 0, skipArcs, null, null,
                    null, null, null, bbox);

            executor.execute(run);
        }

        // Waiting the end of the operations of each thread
        latch.await();
        // Executor termination
        executor.shutdown();

        executor.awaitTermination(TIMEOUT, TimeUnit.SECONDS);

        // Check if any thread reports a failure
        if (threadFailure.get()) {
            throw new IllegalStateException("Error on calculating vulnerability");
        }

        // HUMAN
        // Reset of the input cell Set
        set.clear();
        // Change of the input target to Human
        targetID = "Human";
        // Latch and executor creation
        latch = new CountDownLatch(threadMaxNumber);
        executor = new ThreadPoolExecutor(threadMaxNumber, threadMaxNumber, 60, TimeUnit.SECONDS,
                new ArrayBlockingQueue<Runnable>(1000000));

        // Cycle on all the cell groups
        for (int i = 0; i < threadMaxNumber; i++) {
            Double min = (Double) groups.getMin(i);
            Double max = (Double) groups.getMax(i);

            VulnerabilityComputation vulnerability = new VulnerabilityComputation(inputFeature,
                    listenerForwarder, metadataHandler, dataStore);
            // Setting of the Id bounds for the calculation
            vulnerability.setStartOriginId(min.longValue());
            vulnerability.setEndOriginId(max.longValue());

            MyRunnable run = new MyRunnable(vulnerability, aggregationLevel, writeMode, closePhase,
                    images[0], bandPerTargetH, set, targetID, 0, 0, 0, 0, skipArcs, null, null,
                    null, null, null, bbox);

            executor.execute(run);
        }
        // Waiting the end of the operations of each thread
        latch.await();
        // Executor termination
        executor.shutdown();

        executor.awaitTermination(TIMEOUT, TimeUnit.SECONDS);

        // Check if any thread reports a failure
        if (threadFailure.get()) {
            throw new IllegalStateException("Error on calculating vulnerability");
        }
    }

    /**
     * Inner class used for calculating vulnerability inside each separate thread
     */
    class MyRunnable implements Runnable {

        private VulnerabilityComputation vln;

        private int aggregationLevel;

        private String writeMode;

        private String closePhase;

        private RenderedImage currentImage;

        private Map<Integer, TargetInfo> currentBPT;

        private ConcurrentSkipListSet<BigDecimal> keySet;

        private String targetID;

        private int minTileX;

        private int maxTileX;

        private int minTileY;

        private int maxTileY;

        private boolean skipArcs;

        private Integer xStart;

        private Integer yStart;

        private Integer xStop;

        private Integer yStop;

        private String idStart;

        private Envelope2D bbox;

        /**
         * Creation of a new {@link Runnable} which calculates the vulnerability for the defined portion of the image
         * 
         * @param vln
         * @param aggregationLevel
         * @param writeMode
         * @param closePhase
         * @param currentImage
         * @param currentBPT
         * @param keySet
         * @param targetID
         * @param minTileX
         * @param maxTileX
         * @param minTileY
         * @param maxTileY
         * @param skipArcs
         * @param xStart
         * @param yStart
         * @param xStop
         * @param yStop
         * @param idStart
         * @param bbox
         */
        MyRunnable(VulnerabilityComputation vln, int aggregationLevel, String writeMode,
                String closePhase, RenderedImage currentImage, Map<Integer, TargetInfo> currentBPT,
                ConcurrentSkipListSet<BigDecimal> keySet, String targetID, int minTileX,
                int maxTileX, int minTileY, int maxTileY, boolean skipArcs, Integer xStart,
                Integer yStart, Integer xStop, Integer yStop, String idStart, Envelope2D bbox) {
            // Definition of all the requested variables
            this.vln = vln;
            this.aggregationLevel = aggregationLevel;
            this.writeMode = writeMode;
            this.closePhase = closePhase;
            this.currentImage = currentImage;
            this.currentBPT = currentBPT;
            this.keySet = keySet;
            this.targetID = targetID;
            this.minTileX = minTileX;
            this.maxTileX = maxTileX;
            this.minTileY = minTileY;
            this.maxTileY = maxTileY;
            this.skipArcs = skipArcs;
            this.xStart = xStart;
            this.yStart = yStart;
            this.xStop = xStop;
            this.yStop = yStop;
            this.idStart = idStart;
            this.bbox = bbox;
        }

        @Override
        public void run() {
            try {
                vln.computeVulnerability(null, aggregationLevel, writeMode, closePhase,
                        currentImage, currentBPT, keySet, targetID, minTileX, maxTileX, minTileY,
                        maxTileY, skipArcs, xStart, yStart, xStop, yStop, idStart, bbox);
            } catch (Exception e) {
                LOGGER.error("Error Calculating Vulnerability from tile (" + minTileX + ","
                        + minTileY + ") and (" + maxTileX + "," + maxTileY + ")");
                threadFailure.getAndSet(true);
            }

            latch.countDown();
        }
    }
}
