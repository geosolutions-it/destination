/*
 *  Copyright (C) 2007-2012 GeoSolutions S.A.S.
 *  http://www.geo-solutions.it
 *
 *  GPLv3 + Classpath exception
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.geosolutions.geobatch.destination.vulnerability;

import it.geosolutions.geobatch.destination.common.InputObject;
import it.geosolutions.geobatch.destination.common.OutputObject;
import it.geosolutions.geobatch.destination.ingestion.MetadataIngestionHandler;
import it.geosolutions.geobatch.destination.vulnerability.TargetManager.TargetInfo;
import it.geosolutions.geobatch.destination.vulnerability.VulnerabilityOperation.OperationType;
import it.geosolutions.geobatch.flow.event.ProgressListenerForwarder;
import it.geosolutions.jaiext.bandmerge.BandMergeDescriptor;
import it.geosolutions.jaiext.nullop.NullDescriptor;

import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.image.DataBuffer;
import java.awt.image.RenderedImage;
import java.io.File;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.media.jai.JAI;
import javax.media.jai.PlanarImage;
import javax.media.jai.RenderedOp;

import org.geotools.data.DefaultTransaction;
import org.geotools.data.FeatureSource;
import org.geotools.data.Transaction;
import org.geotools.feature.FeatureIterator;
import org.geotools.geometry.DirectPosition2D;
import org.geotools.geometry.Envelope2D;
import org.geotools.jdbc.JDBCDataStore;
import org.geotools.referencing.CRS;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;
import org.opengis.filter.Filter;
import org.opengis.referencing.FactoryException;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.opengis.referencing.operation.MathTransform;
import org.opengis.referencing.operation.NoninvertibleTransformException;
import org.opengis.referencing.operation.TransformException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vividsolutions.jts.geom.Geometry;

/**
 * This class is the entry point for the vulnerability process (method computeVulnerability) and it implements the computation's main loop
 * 
 * @author DamianoG
 * @author Daniele Romagnoli, GeoSolutions SAS
 */
public class VulnerabilityComputation extends InputObject {

    private static final int MAX_TEMP_CALC = 20;

    private static final int BBOX_COORD_NUM = 4;

    private final static Logger LOGGER = LoggerFactory.getLogger(VulnerabilityComputation.class);

    private static Pattern TYPE_NAME_PARTS = Pattern
            .compile("^([A-Z]{2})_([A-Z]{1})_([A-Za-z]+)_([0-9]{8})(_ORIG)?$");

    // private static Pattern TYPE_NAME_PARTS = Pattern
    // .compile("^([A-Z]{2})_([A-Z]{1})_([A-Za-z]+)_([0-9]{8})$");

    public static String GEO_TYPE_NAME = "siig_geo_ln_arco_X";

    public static String VULNERABILITY_TYPE_NAME = "siig_t_vulnerabilita_X";

    private static String DISTANCE_TYPE_NAME = "siig_d_distanza";

    private static String ID_GEO_ARCO = "id_geo_arco";

    public static String PARTNER_FIELD = "fk_partner";

    public static String GEOID = "id_geo_arco";

    public final static String RASTER_PATH_PROP = "SIIG_RASTERS_PATH";

    private Long startOriginId;

    private Long endOriginId;

    private Long totPages;

    private Long pageNumber;

    private int pixelArea;

    private Map vulnerabilityCfg;

    String codicePartner;

    int partner;

    /**
     * @param startOriginId the startOriginId to set
     */
    public void setStartOriginId(Long startOriginId) {
        this.startOriginId = startOriginId;
    }

    /**
     * @param endOriginId the endOriginId to set
     */
    public void setEndOriginId(Long endOriginId) {
        this.endOriginId = endOriginId;
    }

    /**
     * @param pixelArea the pixelArea to set
     */
    public void setPixelArea(int pixelArea) {
        this.pixelArea = pixelArea;
    }

    /**
     * @param totPages the totPages to set
     */
    public void setTotPages(Long totPages) {
        this.totPages = totPages;
    }

    /**
     * @param pageNumber the pageNumber to set
     */
    public void setPageNumber(Long pageNumber) {
        this.pageNumber = pageNumber;
    }

    /**
     * @param inputTypeName
     * @param listenerForwarder
     */
    public VulnerabilityComputation(String inputTypeName,
            ProgressListenerForwarder listenerForwarder, MetadataIngestionHandler metadataHandler,
            JDBCDataStore dataStore) {
        super(inputTypeName, listenerForwarder, metadataHandler, dataStore);
        // default area
        pixelArea = 100;
    }

    @Override
    protected String getInputTypeName(String inputTypeName) {
        return inputTypeName.replace("_ORIG", "");
    }

    @Override
    protected boolean parseTypeName(String typeName) {
        Matcher m = TYPE_NAME_PARTS.matcher(typeName);
        if (m.matches()) {
            // partner alphanumerical abbreviation (from siig_t_partner)
            codicePartner = m.group(1);
            // partner numerical id (from siig_t_partner)
            partner = Integer.parseInt(partners.get(codicePartner).toString());

            return true;
        }
        return false;
    }

    private String getTypeName(String typeName, int aggregationLevel) {
        return typeName.replace("X", aggregationLevel + "");
    }

    /**
     * Compute the vulnerability for each arc. The Algorithm is:
     * 
     * ForEach(target) buffers = computeBuffers(allDistance, arc); ForEach(distance) if(!isAccepted(distance,target)) saveOnDB(0,arc,target,distance)
     * continue; sum = computeSum(buffer, target); ForEach(arc) saveOnDB(sum,arc,target,distance);
     * 
     * 
     * @param datastoreParams
     * @param crs
     * @param aggregationLevel
     * @throws IOException
     */
    public void computeVulnerability(CoordinateReferenceSystem crs, int aggregationLevel,
            String writeMode, String closePhase) throws IOException {

        reset();
        if (isValid()) {

            crs = checkCrs(crs);

            String outFeatureName = getTypeName(VULNERABILITY_TYPE_NAME, aggregationLevel);

            int process = -1;
            int trace = -1;
            int errors = 0;
            long otherErrors = 0;

            // existing process
            MetadataIngestionHandler.Process importData = getProcessData();
            process = importData.getId();
            trace = importData.getMaxTrace();
            errors = importData.getMaxError();
            int startErrors = errors;

            if (process == -1) {
                LOGGER.error("Cannot find process for input file");
                throw new IOException("Cannot find process for input file");
            }

            //
            // Load All needed resources: properties files, Rendered Images, GeotifReaders
            //
            vulnerabilityCfg = (Map) readResourceFromXML("/vulnerability.xml");
            String basePath = System.getProperty(RASTER_PATH_PROP, "");
            if (!basePath.equals("")) {
                basePath = basePath + File.separator + codicePartner;
            }
            VulnerabilityStatsEngine vse = new VulnerabilityStatsEngine(basePath, vulnerabilityCfg,
                    dataStore, DISTANCE_TYPE_NAME, pixelArea);

            ResultStatsMap statsMap = new ResultStatsMap(vulnerabilityCfg);

            // Setup the OutputObject (in thet case the vulnerability table) remove old values for the partner and detect the max id
            Transaction transaction = new DefaultTransaction();
            OutputObject vulnerabilityObj = new OutputObject(dataStore, transaction,
                    outFeatureName, GEOID);

            //
            // Load the concrete operation (Insert or PurgeInsert)
            //
            VulnerabilityOperation insertOperation = VulnerabilityOperation
                    .instantiateWriterFromString(writeMode);
            LOGGER.info("Using writer " + VulnerabilityOperation.class);
            insertOperation.initFeature(vulnerabilityObj, partner);
            // Setup filtering
            insertOperation.setStartOriginId(startOriginId);
            insertOperation.setEndOriginId(endOriginId);
            insertOperation.setPageNumber(pageNumber);
            insertOperation.setTotPages(totPages);

            //
            // Load the concrete operation (Update)
            //
            VulnerabilityOperation updateOperation = VulnerabilityOperation
                    .instantiateWriter(OperationType.UPDATE);
            LOGGER.info("Using writer " + VulnerabilityOperation.class);
            updateOperation.initFeature(vulnerabilityObj, partner);
            // Setup filtering
            updateOperation.setStartOriginId(startOriginId);
            updateOperation.setEndOriginId(endOriginId);
            updateOperation.setPageNumber(pageNumber);
            updateOperation.setTotPages(totPages);

            //
            // Start the vulnerability Computation
            //
            long start = System.nanoTime();
            try {
                SimpleFeature inputFeature = null;
                int loopCounter = 0;
                List<Double> allDistances = vse.getDistances();
                final int reportingLoopStep = allDistances.size() > 10 ? 50 : 100;

                // setup geo input / output object
                String geoName = getTypeName(GEO_TYPE_NAME, aggregationLevel);
                if (aggregationLevel == 3) {
                    geoName = geoName.replace("ln", "pl");
                }
                createInputReader(dataStore, null, geoName);

                Filter partnerFilter = filterFactory.equals(filterFactory.property(PARTNER_FIELD),
                        filterFactory.literal(partner));
                setInputFilter(partnerFilter);

                int total = getImportCount();

                // setInputFilter(concreteOperation.buildOriginFilter(partner, total));

                // calculates total objects to import
                LOGGER.info("import count: " + total);
                Map<String, TargetInfo> targetInfo = vse.getTargetInfo();

                LOGGER.info("Start computation: ThreadName: " + Thread.currentThread().getName()
                        + " - startOriginId: " + startOriginId + " - endOriginId: " + endOriginId);
                String targetID = null;
                String idArco = null;
                Double currentDistance = null;

                /*
                 * Creation of 2 images: one for the HUMAN TARGETS and the other for NOT HUMAN TARGETS
                 */
                // List of Human Targets
                List<RenderedImage> humanList = new ArrayList<RenderedImage>();
                // Image associated with the human targets
                RenderedImage humanTargets = null;

                // List of Not Human Targets
                List<RenderedImage> notHumanList = new ArrayList<RenderedImage>();

                // Image associated with the not human targets
                RenderedImage notHumanTargets = null;

                // Map which contains the informations for each human target
                Map<Integer, TargetInfo> bandPerTargetH = new TreeMap<Integer, TargetManager.TargetInfo>();

                // Map which contains the informations for each not human target
                Map<Integer, TargetInfo> bandPerTargetNH = new TreeMap<Integer, TargetManager.TargetInfo>();

                // Counters indicating which band is associated to the TargetInfo and Image
                int humanBandCounter = 0;
                int notHumanBandCounter = 0;

                // Iterator on all the targets
                Iterator rasterIter = targetInfo.keySet().iterator();

                /*targetID = (String) rasterIter.next();

                TargetInfo infoTarget = targetInfo.get(targetID);

                RenderedImage firstImage = infoTarget.getRaster();

                MathTransform g2wTransf;

                try {
                    g2wTransf = infoTarget.getWorld2Grid().inverse();
                } catch (NoninvertibleTransformException e1) {
                    throw new RuntimeException("Non invertible transformation");
                }

                Rectangle imageBounds = new Rectangle(firstImage.getMinX(), firstImage.getMinY(),
                        firstImage.getWidth(), firstImage.getHeight());

                double[] rasterCoord = new double[] { imageBounds.getMinX(), imageBounds.getMinY(),
                        imageBounds.getMaxX(), imageBounds.getMaxY() };

                double[] geoCoord = new double[rasterCoord.length];

                try {
                    g2wTransf.transform(rasterCoord, 0, geoCoord, 0, 2);
                } catch (TransformException e1) {
                    throw new RuntimeException("An error occurred when transforming "
                            + "from raster to model space");
                }*/

//                String wkt = "";
//
//                try {
//                    CRS.parseWKT(wkt);
//                } catch (FactoryException e1) {
//                    throw new RuntimeException("An error occurred when parsing WKT");
//                }

                // ReferencedEnvelope refEnv = new ReferencedEnvelope();
                //
                // //ReferencedEnvelope refEnv = (ReferencedEnvelope) rasterIMG;
                //
                //
                // AreaGridProcess areaProcess;
                //
                // areaProcess = new AreaGridProcess();
                //
                // GridCoverage2D gridArea = areaProcess.execute(refEnv, imageBounds.width, imageBounds.height);
                //
                // RenderedImage rasterArea = gridArea.getRenderedImage();
                //
                // StatsType[] types = new StatsType[]{StatsType.MEAN};
                //
                //
                //
                //
                // RenderedOp imageMean = StatisticsDescriptor.create(rasterArea, 1, 1, null, null, false, new int[]{0}, types, null);
                //
                // double meanArea = (Double) ((Statistics[])imageMean.getProperty(Statistics.STATS_PROPERTY))[0].getResult();
                //
                // System.out.println("The mean Raster Area is " +meanArea+ " mq");

                // HP 1 ALL THE TARGETS HAVE THE SAME NODATA
                // HP 2 ALL THE TARGETS HAVE THE SAME WORLD2GRID TRANSFORMATION
                // HP 3 ALL THE TARGETS HAVE THE SAME DIMENSIONS

                while (rasterIter.hasNext()) {
                    // save the ID of this target
                    targetID = (String) rasterIter.next();

                    // Load the target manager, init its status and check if the actual distance is a valid distance for it
                    TargetInfo info = targetInfo.get(targetID);

                    TargetManager manager = info.getManager();

                    // Image associated to the current target
                    RenderedImage newImage = info.getRaster();

                    int imgDataType = newImage.getSampleModel().getDataType();

                    if (newImage != null) {
                        // If the target is human
                        if (manager.isHumanTarget()) {

                            if (imgDataType != DataBuffer.TYPE_FLOAT) {
                                System.out.println("Wrong data type");
                            }

                            // Addition of the TargetInfo of this target
                            bandPerTargetH.put(humanBandCounter, info);
                            // Update of the bandCounter
                            humanBandCounter++;
                            // Addition of the image to the associated list
                            humanList.add(newImage);
                            // If the target is not human
                        } else {

                            if (imgDataType != DataBuffer.TYPE_BYTE) {
                                System.out.println("Wrong data type");
                            }

                            // Addition of the TargetInfo of this target
                            bandPerTargetNH.put(notHumanBandCounter, info);
                            // Update of the bandCounter
                            notHumanBandCounter++;
                            // Addition of the image to the associated list
                            notHumanList.add(newImage);
                        }
                    }
                }

                // BandMerge of the images
                RenderedImage[] imagesHuman = new RenderedImage[humanList.size()];
                RenderedImage[] imagesNotHuman = new RenderedImage[notHumanList.size()];

                humanTargets = BandMergeDescriptor.create(null, 0,
                        VulnerabilityUtils.NO_TILE_CACHE, humanList.toArray(imagesHuman));

                notHumanTargets = BandMergeDescriptor.create(null, 0,
                        VulnerabilityUtils.NO_TILE_CACHE, notHumanList.toArray(imagesNotHuman));

                // cache the final image
                humanTargets = NullDescriptor.create(humanTargets, new RenderingHints(
                        JAI.KEY_TILE_CACHE, JAI.getDefaultInstance().getTileCache()));
                // ((RenderedOp)humanTargets).getTiles();
                notHumanTargets = NullDescriptor.create(notHumanTargets, new RenderingHints(
                        JAI.KEY_TILE_CACHE, JAI.getDefaultInstance().getTileCache()));

                humanTargets.getHeight();
                notHumanTargets.getHeight();

                // Current TargetInfo Map used
                Map<Integer, TargetInfo> currentBPT;

                // Current vulnerability operation
                VulnerabilityOperation concreteOperation;

                // Elaboration on both the 2 images
                for (int target = 0; target < 2; target++) {

                    // Current image used in calculation
                    RenderedImage currentImage;
                    // Human targets
                    if (target == 1) {

                        currentImage = humanTargets;

                        currentBPT = bandPerTargetH;

                        concreteOperation = updateOperation;
                        // Not Human targets
                    } else {

                        currentImage = notHumanTargets;

                        currentBPT = bandPerTargetNH;

                        concreteOperation = insertOperation;
                    }

                    try {
                        // Creation of a List of features
                        List<SimpleFeature> arcList = new ArrayList<SimpleFeature>();

                        // Creation of a set containing all of the geometry keys
                        Set<BigDecimal> keySet = new LinkedHashSet<BigDecimal>();

                        if (aggregationLevel != 3) {
                            // Creation of a list of the arc Ids
                            List<String> arcIds = new ArrayList<String>();
                            // Creation of a BufferList
                            List<MultipleBufferMap> bufferList = new ArrayList<MultipleBufferMap>();
                            // Creation of a temporary arcList
                            List<SimpleFeature> temporaryList = new ArrayList<SimpleFeature>(1);
                            // Creation of a temporary geometryList
                            List<Geometry> geometryList = new ArrayList<Geometry>();
                            // Creation of a temporary ResultMapList
                            List<ResultStatsMap> statList = new ArrayList<ResultStatsMap>();
                            // Load the Transformation associated with the selected target and calculate the inverse
                            TargetInfo firstInfo = currentBPT.get(0);
                            MathTransform w2g = firstInfo.getWorld2Grid();
                            MathTransform g2w = w2g.inverse();
                            // Load the target dimensions for modifying the spatial filter
                            int minX = 0;
                            int minY = 0;
                            // Tile indexes
                            int minTileX = currentImage.getMinTileX();
                            int minTileY = currentImage.getMinTileY();
                            int maxTileX = minTileX + currentImage.getNumXTiles();
                            int maxTileY = minTileY + currentImage.getNumYTiles();

                            int tileWidth = currentImage.getTileWidth();
                            int tileHeight = currentImage.getTileHeight();

                            int tileGridX = currentImage.getTileGridXOffset();

                            int tileGridY = currentImage.getTileGridYOffset();

                            double[] srcPts = new double[BBOX_COORD_NUM];

                            double[] dstPts = new double[BBOX_COORD_NUM];

                            DirectPosition2D minXY = new DirectPosition2D(0, 0);

                            DirectPosition2D maxXY = new DirectPosition2D(0, 0);
                            // Setting of the bounding box
                            Envelope2D env = new Envelope2D(minXY, maxXY);

                            double height = 0;
                            double width = 0;

                            // Iteration on image tiles
                            for (int x = minTileX; x < maxTileX; x++) {

                                // For each tile, the points are transformed in the world crs

                                minX = PlanarImage.tileXToX(x, tileGridX, tileWidth);

                                for (int y = minTileY; y < maxTileY; y++) {

                                    minY = PlanarImage.tileYToY(y, tileGridY, tileHeight);

                                    // Source Coordinates
                                    srcPts[0] = minX;
                                    srcPts[1] = minY;
                                    srcPts[2] = minX + tileWidth;
                                    srcPts[3] = minY + tileHeight;
                                    // Coordinates transformation
                                    g2w.transform(srcPts, 0, dstPts, 0, 2);
                                    // Creation of the BoundingBox associated with the selected tile
                                    height = Math.abs(dstPts[3] - dstPts[1]);
                                    width = Math.abs(dstPts[2] - dstPts[0]);

                                    env.x = dstPts[0];
                                    env.y = dstPts[1];
                                    env.height = height;
                                    env.width = width;

                                    // Creation of a spatial filter for taking only the features associated
                                    // to the selected bounding box
                                    setInputFilter(concreteOperation.buildOriginFilter(partner,
                                            total, env));

                                    // The input filter is created, then we check
                                    // the size of the input features returned
                                    int featureSize = inputSize();

                                    int featureCounter = 0;

                                    while (featureCounter < featureSize) {

                                        int temporaryCounter = 0;

                                        // Iteration on the image tile for searching all the geometries
                                        while (temporaryCounter <= MAX_TEMP_CALC
                                                && (inputFeature = readInput()) != null) {
                                            // Selection of the id associated to the feature.
                                            BigDecimal arcId = ((BigDecimal) inputFeature
                                                    .getAttribute(ID_GEO_ARCO));
                                            // Check if the feature has been already taken
                                            boolean notContained = keySet.add(arcId);
                                            if (notContained) {
                                                arcList.add(inputFeature);
                                                // Selection of the arc id
                                                idArco = arcId.toString();
                                                // Update of the arc id list
                                                arcIds.add(idArco);
                                                // /// computeBuffersOnArcs
                                                // Addition on the temporary list
                                                temporaryList.add(inputFeature);
                                                MultipleBufferMap mbm = vse.computeBuffersOnArcs(
                                                        temporaryList, allDistances);
                                                temporaryList.clear();
                                                // Add the buffer for the selected arc
                                                bufferList.add(mbm);

                                                // Update of the logger in debug
                                                if (LOGGER.isDebugEnabled() && inputFeature != null) {
                                                    LOGGER.debug("Computing arc "
                                                            + inputFeature.getID());
                                                }
                                            }

                                            temporaryCounter++;

                                        }

                                        // BUFFER CALCULATION

                                        // If almost an arc is present
                                        int arcSize = arcList.size();

                                        if (arcSize > 0) {

                                            String id = null;

                                            // Iteration on all the buffers
                                            for (Double processedDistance : allDistances) {

                                                // Check if the distance is related to the selected target
                                                // Empty map used for containing only the accepted targets
                                                Map<Integer, TargetInfo> acceptedBands = new TreeMap<Integer, TargetManager.TargetInfo>();
                                                // Set of all the bands
                                                Set<Integer> keys = currentBPT.keySet();
                                                // Cycle on all the targets
                                                for (int band : keys) {
                                                    // Selection of the TargetInfo
                                                    TargetInfo infoPerBand = currentBPT.get(band);
                                                    // TargetManager associated
                                                    TargetManager mng = infoPerBand.getManager();
                                                    // If the distance is related to the target, then it is added to the map of the accepted band
                                                    if (mng.isDistanceRelatedToTarget(processedDistance)) {
                                                        acceptedBands.put(band, infoPerBand);
                                                    }
                                                }
                                                // Statistical computation

                                                // The statistics are calculated only if almost one of the targets accepts the current distance
                                                if (!acceptedBands.isEmpty()) {
                                                    // Number of ResultStatsMap already present
                                                    int statListSize = statList.size();
                                                    // Number of buffer to calculate
                                                    int buffListSize = bufferList.size();
                                                    // If the ResultStatsMap are not enough, they are calculated until they reach the desired number
                                                    if (statListSize < buffListSize) {
                                                        int difference = buffListSize
                                                                - statListSize;

                                                        for (int i = 0; i < difference; i++) {
                                                            statList.add(new ResultStatsMap(
                                                                    vulnerabilityCfg));
                                                        }
                                                    }
                                                    // Addition of the buffer associated with the selected distance and arc
                                                    for (MultipleBufferMap mbm : bufferList) {

                                                        // Use the cell for crop the raster if the aggregation level == 3, use the buffer otherwise
                                                        Geometry bufferArea = (Geometry) mbm
                                                                .getBuffersForDistance(
                                                                        processedDistance).get(0);

                                                        geometryList.add(bufferArea);
                                                    }
                                                    // Calculation
                                                    vse.computeStats(geometryList, currentImage,
                                                            statList, false, acceptedBands);
                                                    // The Buffer List is cleared
                                                    geometryList.clear();
                                                }
                                                // Iteration on all the geometries list
                                                for (int i = 0; i < arcSize; i++) {
                                                    // Update of the Loop Counter
                                                    loopCounter++;
                                                    // When a certain number of geometries are calculated, a report is printed
                                                    if (loopCounter % reportingLoopStep == 0) {
                                                        LOGGER.info("computed arcs FROM -"
                                                                + (loopCounter - 100) + "- TO -"
                                                                + loopCounter + "-");
                                                    }
                                                    // Selection of the arc
                                                    SimpleFeature arc = arcList.get(i);
                                                    // Selection of the arcId
                                                    String arcId = arcIds.get(i);

                                                    // Creation of the identifier associated with the distance
                                                    id = buildFid(arcId, processedDistance);
                                                    // DEBUG: indication of which arc is calculated
                                                    if (LOGGER.isDebugEnabled()) {
                                                        LOGGER.debug("Computing arc " + arc.getID());
                                                    }

                                                    // ResultStatsMap associated with the arc
                                                    ResultStatsMap resMap;
                                                    if (!acceptedBands.isEmpty()) {
                                                        resMap = statList.get(i);
                                                    } else {
                                                        resMap = statsMap;
                                                    }

                                                    try {
                                                        // Writing of the result for the selected distance and Id
                                                        concreteOperation.writeOutputObjects(trace,
                                                                vulnerabilityObj, total,
                                                                outFeatureName, arc, id,
                                                                resMap.getStatsMap(), partner);
                                                    } catch (Exception e) {
                                                        errors++;
                                                        metadataHandler.logError(trace, errors,
                                                                "Error writing objects on "
                                                                        + geoName, getError(e), 0);
                                                        LOGGER.error("Error writing objects on "
                                                                + geoName, e);
                                                    }

                                                    // Clearing of the associated ResultStatsMap
                                                    if (!resMap.isEmpty()) {
                                                        resMap.clear();
                                                    }
                                                }
                                            }
                                            // At the end of the operation on this list
                                            // all the geometries are cleared for the next
                                            // cell.
                                            arcList.clear();
                                            arcIds.clear();
                                            bufferList.clear();
                                        }

                                        featureCounter += temporaryCounter;
                                    }
                                    // INPUT READER CLOSURE
                                    try {
                                        closeInputReader();
                                    } catch (Exception e) {
                                        errors++;
                                        metadataHandler.logError(trace, errors,
                                                "Error closing inputReader", getError(e), 0);
                                        LOGGER.error("Error closing inputReader", e);
                                    }
                                }
                            }
                            // Reset of the Loop Counter
                            if (target == 0) {
                                loopCounter = 0;
                            }
                            // AGGREGATION LEVEL 3
                        } else {
                            // Setting of the input filter
                            setInputFilter(concreteOperation
                                    .buildOriginFilter(partner, total, null));

                            while ((inputFeature = readInput()) != null) {

                                // For level 3, get all the arcs that intersect with the current grid cell
                                FeatureIterator<SimpleFeature> iterator = null;
                                try {
                                    // Cell element
                                    Geometry cell = (Geometry) inputFeature.getDefaultGeometry();
                                    String linearGeoName = geoName.replace("pl", "ln");
                                    FeatureSource<SimpleFeatureType, SimpleFeature> reader = createInputReader(
                                            dataStore, null, linearGeoName);
                                    // Iterator for selecting all the geometries intersecting the cell
                                    iterator = reader.getFeatures(
                                            filterFactory.and(filterFactory.intersects(
                                                    filterFactory.property(getInputGeometryName(
                                                            dataStore, linearGeoName)),
                                                    filterFactory.literal(cell)), partnerFilter))
                                            .features();
                                    while (iterator.hasNext()) {
                                        SimpleFeature sf = (SimpleFeature) iterator.next();
                                        // Selection of the id associated to the feature.
                                        BigDecimal arcId = ((BigDecimal) sf
                                                .getAttribute(ID_GEO_ARCO));
                                        // Check if the feature has been already taken
                                        boolean notContained = keySet.add(arcId);
                                        if (notContained) {
                                            arcList.add(sf);
                                        }
                                    }
                                } catch (Exception e) {
                                    LOGGER.error("Error reading " + geoName, e);
                                    errors++;
                                    metadataHandler.logError(trace, errors, "Error reading "
                                            + geoName, getError(e), 0);
                                } finally {
                                    if (iterator != null) {
                                        iterator.close();
                                    }
                                }
                                // BUFFER CALCULATION
                                // Selection of the arc id
                                idArco = ((BigDecimal) inputFeature.getAttribute(ID_GEO_ARCO))
                                        .toString();
                                // If almost an arc is present
                                if (arcList.size() > 0) {
                                    // computeBuffersOnArcs
                                    MultipleBufferMap mbm = vse.computeBuffersOnArcs(arcList,
                                            allDistances);

                                    String id = null;

                                    // Iteration on all the buffers
                                    for (Double processedDistance : allDistances) {
                                        // Check if the distance is related to the selected target
                                        // Empty map used for containing only the accepted targets
                                        Map<Integer, TargetInfo> acceptedBands = new TreeMap<Integer, TargetManager.TargetInfo>();
                                        // Set of all the bands
                                        Set<Integer> keys = currentBPT.keySet();
                                        // Cycle on all the targets
                                        for (int band : keys) {
                                            // Selection of the TargetInfo
                                            TargetInfo infoPerBand = currentBPT.get(band);
                                            // TargetManager associated
                                            TargetManager mng = infoPerBand.getManager();
                                            // If the distance is related to the target, then it is added to the map of the accepted band
                                            if (mng.isDistanceRelatedToTarget(processedDistance)) {
                                                acceptedBands.put(band, infoPerBand);
                                            }
                                        }
                                        // Creation of the identifier associated with the distance
                                        id = buildFid(idArco, processedDistance);

                                        // Statistics computation

                                        // The statistics are calculated only if almost one of the targets accepts the current distance
                                        if (!acceptedBands.isEmpty()) {
                                            vse.computeStats(
                                                    mbm.getBuffersForDistance(processedDistance),
                                                    currentImage, statsMap, false, acceptedBands);
                                        }
                                        try {
                                            // Writing of the result for the selected distance and Id
                                            concreteOperation.writeOutputObjects(trace,
                                                    vulnerabilityObj, total, outFeatureName,
                                                    inputFeature, id, statsMap.getStatsMap(),
                                                    partner);
                                        } catch (Exception e) {
                                            errors++;
                                            metadataHandler.logError(trace, errors,
                                                    "Error writing objects on " + geoName,
                                                    getError(e), 0);
                                            LOGGER.error("Error writing objects on " + geoName, e);
                                        }
                                    }
                                    // At the end of the operation on this list
                                    // all the geometries are cleared for the next
                                    // cell
                                    arcList.clear();
                                }
                                // Update of the LoopCounter
                                loopCounter++;

                                // When a certain number of geometries are calculated, a report is printed
                                if (loopCounter % reportingLoopStep == 0) {
                                    LOGGER.info("computed arcs FROM -" + (loopCounter - 100)
                                            + "- TO -" + loopCounter + "-");
                                }
                                // DEBUG: indication of which arc is calculated
                                if (LOGGER.isDebugEnabled() && inputFeature != null) {
                                    LOGGER.debug("Computing arc " + inputFeature.getID());
                                }
                            }
                        }
                    } catch (Exception e) {
                        errors++;
                        metadataHandler.logError(trace, errors, "Error occurred on raster: "
                                + targetID + " for distance " + currentDistance + " on arc:"
                                + idArco, getError(e), 0);
                        LOGGER.error("Error occurred on raster: " + targetID + " for distance "
                                + currentDistance + " on arc:" + idArco + "\n" + e.getMessage(), e);
                    } finally {
                        try {

                            if (currentImage instanceof RenderedOp) {
                                ((RenderedOp) currentImage).dispose();
                            }

                            closeInputReader();
                        } catch (Exception e) {
                            errors++;
                            metadataHandler.logError(trace, errors, "Error closing inputReader",
                                    getError(e), 0);
                            LOGGER.error("Error closing inputReader", e);
                        }
                    }
                }

                // Report about the end of the input
                importFinishedModified(total, loopCounter, errors - startErrors,
                        "Data imported in " + outFeatureName);
            } finally {
                closeInputReader();
                LOGGER.info("Write errors: " + errors + " - other errors: " + otherErrors);

                if (process != -1 && closePhase != null) {
                    // close current process phase
                    metadataHandler.closeProcessPhase(process, closePhase);
                }
                transaction.close();
                dataStore.dispose();
            }

            long end = System.nanoTime() - start;

            double time = end * (10E-9) / 60;

            System.out
                    .println("New version of the vulnerability computation for the aggregation level "
                            + aggregationLevel + " takes " + time + " minutes");

        }
    }

    private static String buildFid(String idArco, Double el) {
        return idArco + "." + el.intValue();
    }
}
