/*
 *  Copyright (C) 2007-2012 GeoSolutions S.A.S.
 *  http://www.geo-solutions.it
 *
 *  GPLv3 + Classpath exception
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.geosolutions.geobatch.destination.vulnerability;

import it.geosolutions.geobatch.destination.common.InputObject;
import it.geosolutions.geobatch.destination.common.OutputObject;
import it.geosolutions.geobatch.destination.common.utils.FeatureLoaderUtils;
import it.geosolutions.geobatch.destination.ingestion.MetadataIngestionHandler;
import it.geosolutions.geobatch.destination.vulnerability.TargetManager.TargetInfo;
import it.geosolutions.geobatch.flow.event.ProgressListenerForwarder;
import it.geosolutions.jaiext.bandmerge.BandMergeCRIF;
import it.geosolutions.jaiext.bandmerge.BandMergeDescriptor;
import it.geosolutions.jaiext.nullop.NullCRIF;
import it.geosolutions.jaiext.nullop.NullDescriptor;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.image.DataBuffer;

import java.awt.image.RenderedImage;
import java.io.File;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.media.jai.PlanarImage;

import java.util.Set;
import java.util.TreeMap;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.media.jai.BorderExtender;
import javax.media.jai.JAI;
import javax.media.jai.PlanarImage;
import javax.media.jai.operator.BorderDescriptor;
import org.geotools.data.DefaultTransaction;
import org.geotools.data.FeatureSource;
import org.geotools.data.Query;
import org.geotools.data.Transaction;
import org.geotools.feature.FeatureCollection;
import org.geotools.feature.FeatureIterator;
import org.geotools.geometry.DirectPosition2D;
import org.geotools.geometry.Envelope2D;

import org.geotools.image.jai.Registry;

import org.geotools.jdbc.JDBCDataStore;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;
import org.opengis.filter.Filter;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.opengis.referencing.operation.MathTransform;
import org.opengis.referencing.operation.NoninvertibleTransformException;
import org.opengis.referencing.operation.TransformException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.vividsolutions.jts.geom.Geometry;

/**
 * This class is the entry point for the vulnerability process (method computeVulnerability) and it implements the computation's main loop
 * 
 * @author DamianoG
 * @author Nicola Lagomarsini
 * @author Daniele Romagnoli, GeoSolutions SAS
 */
public class VulnerabilityComputation extends InputObject {

    public static final String JAI_EXT_PRODUCT = "it.geosolutions.jaiext.roiaware";

    private static final int MAX_TEMP_CALC = 20;

    private static final int BBOX_COORD_NUM = 4;

    private final static Logger LOGGER = LoggerFactory.getLogger(VulnerabilityComputation.class);

    private static Pattern TYPE_NAME_PARTS = Pattern
            .compile("^([A-Z]{2})_([A-Z]{1})_([A-Za-z]+)_([0-9]{8})(_ORIG)?$");

    public static String GEO_TYPE_NAME = "siig_geo_ln_arco_X";

    public static String VULNERABILITY_TYPE_NAME = "siig_t_vulnerabilita_X";

    private static String DISTANCE_TYPE_NAME = "siig_d_distanza";

    private static String ID_GEO_ARCO = "id_geo_arco";

    public static String PARTNER_FIELD = "fk_partner";

    public static String GEOID = "id_geo_arco";

    public final static String RASTER_PATH_PROP = "SIIG_RASTERS_PATH";

    private static final BorderExtender type = BorderExtender
            .createInstance(BorderExtender.BORDER_ZERO);

    private Long startOriginId;

    private Long endOriginId;

    private Long totPages;

    private Long pageNumber;

    private int pixelArea;

    private Map vulnerabilityCfg;

    String codicePartner;

    int partner;

    static {
        try {
            Registry.registerRIF(JAI.getDefaultInstance(), new BandMergeDescriptor(),
                    new BandMergeCRIF(), JAI_EXT_PRODUCT);

            Registry.registerRIF(JAI.getDefaultInstance(), new NullDescriptor(), new NullCRIF(),
                    JAI_EXT_PRODUCT);

        } catch (Throwable e) {
            // swallow exception in case the op has already been registered.
        }
    }

    /**
     * @param startOriginId the startOriginId to set
     */
    public void setStartOriginId(Long startOriginId) {
        this.startOriginId = startOriginId;
    }

    /**
     * @param endOriginId the endOriginId to set
     */
    public void setEndOriginId(Long endOriginId) {
        this.endOriginId = endOriginId;
    }

    /**
     * @param pixelArea the pixelArea to set
     */
    public void setPixelArea(int pixelArea) {
        this.pixelArea = pixelArea;
    }

    /**
     * @param totPages the totPages to set
     */
    public void setTotPages(Long totPages) {
        this.totPages = totPages;
    }

    /**
     * @param pageNumber the pageNumber to set
     */
    public void setPageNumber(Long pageNumber) {
        this.pageNumber = pageNumber;
    }

    /**
     * @param inputTypeName
     * @param listenerForwarder
     */
    public VulnerabilityComputation(String inputTypeName,
            ProgressListenerForwarder listenerForwarder, MetadataIngestionHandler metadataHandler,
            JDBCDataStore dataStore) {
        super(inputTypeName, listenerForwarder, metadataHandler, dataStore);
        // default area
        pixelArea = 100;
    }

    @Override
    protected String getInputTypeName(String inputTypeName) {
        return inputTypeName.replace("_ORIG", "");
    }

    @Override
    protected boolean parseTypeName(String typeName) {
        Matcher m = TYPE_NAME_PARTS.matcher(typeName);
        if (m.matches()) {
            // partner alphanumerical abbreviation (from siig_t_partner)
            codicePartner = m.group(1);
            // partner numerical id (from siig_t_partner)
            partner = Integer.parseInt(partners.get(codicePartner).toString());

            return true;
        }
        return false;
    }

    private String getTypeName(String typeName, int aggregationLevel) {
        return typeName.replace("X", aggregationLevel + "");
    }

    /**
     * Compute the vulnerability for each arc. The Algorithm is:
     * 
     * ForEach(target) buffers = computeBuffers(allDistance, arc); ForEach(distance) if(!isAccepted(distance,target)) saveOnDB(0,arc,target,distance)
     * continue; sum = computeSum(buffer, target); ForEach(arc) saveOnDB(sum,arc,target,distance);
     * 
     * 
     * @param datastoreParams
     * @param crs
     * @param aggregationLevel
     * @param bbox
     * @throws IOException
     */
    public void computeVulnerability(CoordinateReferenceSystem crs, int aggregationLevel,
            String writeMode, String closePhase, RenderedImage currentImage,
            Map<Integer, TargetInfo> currentBPT, ConcurrentSkipListSet<BigDecimal> keySet,
            String targetID, int minTileX, int maxTileX, int minTileY, int maxTileY,
            boolean skipArcs, Integer xStart, Integer yStart, Integer xStop, Integer yStop,
            String idStart, Envelope2D bbox) throws IOException {

        reset();
        // Initial checks
        if (isValid()) {

            crs = checkCrs(crs);

            String outFeatureName = getTypeName(VULNERABILITY_TYPE_NAME, aggregationLevel);

            int process = -1;
            int trace = -1;
            int errors = 0;
            long otherErrors = 0;

            // existing process
            MetadataIngestionHandler.Process importData = getProcessData();
            process = importData.getId();
            trace = (importData.getMaxTrace());
            errors = (importData.getMaxError());
            int startErrors = errors;

            if (process == -1) {
                LOGGER.error("Cannot find process for input file");
                throw new IOException("Cannot find process for input file");
            }

            //
            // Load All needed resources: properties files, Rendered Images,
            // GeotifReaders
            //
            //final TargetPropertiesLoader propertiesLoader = new TargetPropertiesLoader();
            vulnerabilityCfg = (Map) readResourceFromXML("/vulnerability.xml");
            String basePath = System.getProperty(RASTER_PATH_PROP, "");
            if (!basePath.equals("")) {
                basePath = basePath + File.separator + codicePartner;
            }

            VulnerabilityStatsEngine vse = new VulnerabilityStatsEngine(basePath, vulnerabilityCfg,
                    dataStore, DISTANCE_TYPE_NAME, pixelArea);

            ResultStatsMap statsMap = new ResultStatsMap(vulnerabilityCfg);

            // Setup the OutputObject (in thet case the vulnerability table)
            // remove old values for the partner and detect the max id
            Transaction transaction = new DefaultTransaction();
            OutputObject vulnerabilityObj = new OutputObject(dataStore, transaction,
                    outFeatureName, GEOID);

            VulnerabilityOperation concreteOperation;
            // Human targets
            if (targetID.equalsIgnoreCase("Human")) {
                //
                // Load the concrete operation (Update)
                //
                concreteOperation = prepareVulnerabilityOperation("UPDATE", vulnerabilityObj);
                // Not Human targets
            } else {
                //
                // Load the concrete operation (Insert or PurgeInsert)
                //
                concreteOperation = prepareVulnerabilityOperation(writeMode, vulnerabilityObj);
            }
            // Instantiation of the monitor object used in case of an Exception is thrown
            Monitor monitor = new Monitor();
            
            //
            // Start the vulnerability Computation
            //
            try {
                SimpleFeature inputFeature = null;
                int loopCounter = 0;
                List<Double> allDistances = vse.getDistances();
                int reportingLoopStep = allDistances.size() > 10 ? 50 : 100;

                // setup geo input / output object
                String geoName = getTypeName(GEO_TYPE_NAME, aggregationLevel);
                if (aggregationLevel == 3) {
                    geoName = geoName.replace("ln", "pl");
                }
                createInputReader(dataStore, null, geoName);

                Filter partnerFilter = filterFactory.equals(filterFactory.property(PARTNER_FIELD),
                        filterFactory.literal(partner));
                setInputFilter(partnerFilter);

                int total = getImportCount();

                // calculates total objects to import

                LOGGER.info("import count: " + total);
                // Map<String, TargetInfo> targetInfo = vse.getTargetInfo();

                LOGGER.info("Start computation: ThreadName: " + Thread.currentThread().getName()
                        + " - startOriginId: " + startOriginId + " - endOriginId: " + endOriginId);
                // Setting of the monitor parameters
                monitor.setErrors(errors);
                monitor.setLoopCounter(loopCounter);
                try {
                    if (aggregationLevel != 3) {
                        // Vulnerability computation for the level 1 or 2
                        vulnerabilityLevel12(currentImage, currentBPT, keySet, targetID, minTileX,
                                maxTileX, minTileY, maxTileY, skipArcs, xStart, yStart, xStop,
                                yStop, idStart, bbox, outFeatureName, trace, vse, statsMap,
                                transaction, vulnerabilityObj, concreteOperation, monitor,
                                inputFeature, allDistances, reportingLoopStep, geoName, total);
                    } else {
                        // Vulnerability computation for the level 3
                        vulnerabilityLevel3(currentImage, currentBPT, keySet,
                                targetID, bbox, outFeatureName, trace, vse, vulnerabilityObj,
                                concreteOperation, monitor, allDistances, reportingLoopStep,
                                geoName, partnerFilter, total);
                    }
                } catch (Exception e) {
                    monitor.errors++;
                    metadataHandler.logError(trace, monitor.getErrors(), "Raster=" + targetID
                            + ", Error occurred on raster: " + targetID + " for distance "
                            + monitor.getCurrentDistance() + " on arc:" + monitor.getArcId(), getError(e), 0);
                    LOGGER.error(
                            "Raster=" + targetID + ", Error occurred on raster: " + targetID
                                    + " for distance " + monitor.getCurrentDistance() + " on arc:" + monitor.getArcId()
                                    + "\n" + e.getMessage(), e);
                }

                // Report about the end of the input
                importFinishedModified(total, monitor.getLoopCounter(), monitor.getErrors() - startErrors,
                        "Data imported in " + outFeatureName);
            } finally {
                closeInputReader();
                LOGGER.info("Write errors: " + monitor.getErrors() + " - other errors: " + otherErrors);

                if (process != -1 && closePhase != null) {
                    // close current process phase
                    metadataHandler.closeProcessPhase(process, closePhase);
                }
                transaction.close();
            }
        }
    }

    /**
     * This method calculates the vulnerability for the levels 1 and 2
     * 
     * @param currentImage
     * @param currentBPT
     * @param keySet
     * @param targetID
     * @param minTileX
     * @param maxTileX
     * @param minTileY
     * @param maxTileY
     * @param skipArcs
     * @param xStart
     * @param yStart
     * @param xStop
     * @param yStop
     * @param idStart
     * @param bbox
     * @param outFeatureName
     * @param trace
     * @param vse
     * @param statsMap
     * @param transaction
     * @param vulnerabilityObj
     * @param concreteOperation
     * @param monitor
     * @param inputFeature
     * @param allDistances
     * @param reportingLoopStep
     * @param geoName
     * @param total
     * @throws NoninvertibleTransformException
     * @throws TransformException
     * @throws IOException
     */
    private void vulnerabilityLevel12(RenderedImage currentImage,
            Map<Integer, TargetInfo> currentBPT, ConcurrentSkipListSet<BigDecimal> keySet,
            String targetID, int minTileX, int maxTileX, int minTileY, int maxTileY,
            boolean skipArcs, Integer xStart, Integer yStart, Integer xStop, Integer yStop,
            String idStart, Envelope2D bbox, String outFeatureName, int trace,
            VulnerabilityStatsEngine vse, ResultStatsMap statsMap, Transaction transaction,
            OutputObject vulnerabilityObj, VulnerabilityOperation concreteOperation,
            Monitor monitor, SimpleFeature inputFeature, List<Double> allDistances,
            int reportingLoopStep, String geoName, int total)
            throws NoninvertibleTransformException, TransformException, IOException {

        // Creation of a List of features
        List<SimpleFeature> arcList = new ArrayList<SimpleFeature>();

        // Preliminary checks
        if (minTileX > maxTileX) {
            int temp = minTileX;
            minTileX = maxTileX;
            maxTileX = temp;
        }
        if (minTileY > maxTileY) {
            int temp = minTileY;
            minTileY = maxTileY;
            maxTileY = temp;
        }

        // Creation of a list of the arc Ids
        List<String> arcIds = new ArrayList<String>();
        // Load the Transformation associated with the selected
        // target and calculate the inverse
        TargetInfo firstInfo = currentBPT.get(0);
        MathTransform w2g = firstInfo.getWorld2Grid();
        MathTransform g2w = w2g.inverse();
        // Load the target dimensions for modifying the spatial
        // filter
        int minX = 0;
        int minY = 0;

        int tileWidth = currentImage.getTileWidth();
        int tileHeight = currentImage.getTileHeight();

        int tileGridX = currentImage.getTileGridXOffset();

        int tileGridY = currentImage.getTileGridYOffset();

        double[] srcPts = new double[BBOX_COORD_NUM];

        double[] dstPts = new double[BBOX_COORD_NUM];

        DirectPosition2D minXY = new DirectPosition2D(0, 0);

        DirectPosition2D maxXY = new DirectPosition2D(0, 0);
        // Setting of the bounding box
        Envelope2D env = new Envelope2D(minXY, maxXY);

        // Iteration on image tiles
        for (int x = minTileX; x < maxTileX; x++) {

            // For each tile, the points are transformed in the
            // world crs
            minX = PlanarImage.tileXToX(x, tileGridX, tileWidth);

            if (xStart != null && xStart > x) {
                continue;
            }

            if (xStop != null && xStop < x) {
                continue;
            }

            for (int y = minTileY; y < maxTileY; y++) {

                minY = PlanarImage.tileYToY(y, tileGridY, tileHeight);

                if (yStart != null && yStart > y) {
                    continue;
                }

                if (yStop != null && yStop < y) {
                    continue;
                }

                // Source Coordinates
                srcPts[0] = minX;
                srcPts[1] = minY;
                srcPts[2] = minX + tileWidth;
                srcPts[3] = minY + tileHeight;
                // Coordinates transformation
                g2w.transform(srcPts, 0, dstPts, 0, 2);
                // Creation of the BoundingBox associated with
                // the selected tile
                double height = Math.abs(dstPts[1] - dstPts[3]);
                double width = Math.abs(dstPts[0] - dstPts[2]);

                env.x = dstPts[0];// Math.min(dstPts[0], dstPts[2]);
                env.y = dstPts[1];// Math.min(dstPts[1], dstPts[3]);
                env.height = height;
                env.width = width;

                // Creation of a spatial filter for taking only
                // the features associated
                // to the selected bounding box

                if ((xStart != null && x == xStart) && (yStart != null && y == yStart)
                        && idStart != null) {
                    setInputFilter(concreteOperation.buildOriginFilterExtended(partner, total, env,
                            bbox, idStart));
                } else {
                    setInputFilter(concreteOperation.buildOriginFilterExtended(partner, total, env,
                            bbox, null));
                }

                // The input filter is created, then we check
                // the size of the input features returned
                int featureSize = inputSize();

                inputFeature = readInputSorted();
                // Check if the ARC has been already processed
                featureSize = checkInputFeature(targetID, skipArcs, outFeatureName, transaction,
                        inputFeature, featureSize);
                // Temporary List used for buffer computation
                List<SimpleFeature> temporaryList = new ArrayList<SimpleFeature>(1);
                // BufferList
                List<MultipleBufferMap> bufferList = new ArrayList<MultipleBufferMap>();
                // Creation of a temporary ResultMapList
                List<ResultStatsMap> statList = new ArrayList<ResultStatsMap>();

                int featureCounter = 0;
                while (featureCounter < featureSize) {

                    int temporaryCounter = 0;

                    // Iteration on the image tile for searching
                    // all the geometries
                    while (temporaryCounter <= MAX_TEMP_CALC && inputFeature != null) {
                        // Selection of the id associated to the
                        // feature.
                        BigDecimal arcId = ((BigDecimal) inputFeature.getAttribute(ID_GEO_ARCO));

                        // Check if the feature has been already
                        // taken
                        boolean notContained = keySet.add(arcId);
                        if (notContained) {
                            arcList.add(inputFeature);
                            // Selection of the arc id
                            monitor.setArcId(arcId.toString());
                            // Update of the arc id list
                            arcIds.add(monitor.getArcId());

                            // Addition on the temporary list
                            temporaryList.add(inputFeature);
                            MultipleBufferMap mbm = vse.computeBuffersOnArcs(temporaryList,
                                    allDistances);
                            temporaryList.clear();
                            // Add the buffer for the selected
                            // arc
                            bufferList.add(mbm);
                            // Update of the Loop Counter
                            monitor.loopCounter++;
                            // loopCounter++;
                            // Update of the logger in debug
                            if (LOGGER.isDebugEnabled() && inputFeature != null) {
                                LOGGER.debug("Raster=" + targetID + ", TILE=(" + x + "," + y
                                        + ") Computing arc " + monitor.getArcId());
                            }
                        }
                        temporaryCounter++;
                        inputFeature = readInputSorted();
                    }

                    // BUFFER CALCULATION

                    // If almost an arc is present
                    int arcSize = arcList.size();

                    String id = null;

                    if (arcSize > 0) {
                        try {

                            // Iteration on all the buffers
                            for (Double processedDistance : allDistances) {
                                // Update of the currentDistance variable for exception logging
                                monitor.setCurrentDistance(processedDistance);
                                // Check if the distance is
                                // related to the selected
                                // target
                                // Empty map used for containing
                                // only the accepted targets
                                Map<Integer, TargetInfo> acceptedBands = mapAcceptedBands(null,
                                        currentBPT, processedDistance);
                                // Statistical computation

                                // The statistics are calculated
                                // only if almost one of the
                                // targets accepts the current
                                // distance
                                boolean bandAccepted = !acceptedBands.isEmpty();
                                if (bandAccepted) {
                                    // Number of ResultStatsMap
                                    // already present
                                    int statListSize = statList.size();
                                    // Number of buffer to
                                    // calculate
                                    int buffListSize = bufferList.size();
                                    // If the ResultStatsMap are
                                    // not enough, they are
                                    // calculated until they
                                    // reach the desired
                                    // number
                                    if (statListSize < buffListSize) {
                                        int difference = buffListSize - statListSize;

                                        for (int i = 0; i < difference; i++) {
                                            statList.add(new ResultStatsMap(vulnerabilityCfg));
                                        }
                                    }
                                    List<Geometry> geometryList = calculateGeometryList(bufferList,
                                            processedDistance);
                                    // Calculation
                                    try {
                                        vse.computeStats(geometryList, currentImage, statList,
                                                false, acceptedBands);

                                    } catch (Exception e) {
                                        monitor.errors++;
                                        metadataHandler.logError(trace, monitor.getErrors(),
                                                "Raster=" + targetID + ", TILE=(" + x + "," + y
                                                        + ") Error writing objects on " + geoName,
                                                getError(e), 0);
                                        LOGGER.error("Raster=" + targetID + ", TILE=(" + x + ","
                                                + y + ") Error calculating statistics on "
                                                + geoName, e);
                                    }

                                    // When a certain number of
                                    // geometries are
                                    // calculated, a report is
                                    // printed
                                    if (monitor.getLoopCounter() % reportingLoopStep == 0) {
                                        LOGGER.info("Raster=" + targetID + ", TILE=(" + x + "," + y
                                                + ") computed arcs FROM -"
                                                + (monitor.getLoopCounter() - reportingLoopStep)
                                                + "- TO -" + monitor.getLoopCounter() + "-");
                                    }
                                    // The Buffer List is
                                    // cleared
                                    geometryList.clear();
                                }
                                // Iteration on all the
                                // geometries list
                                for (int i = 0; i < arcSize; i++) {

                                    // Selection of the arc
                                    SimpleFeature arc = arcList.get(i);
                                    // Selection of the arcId
                                    String arcId = arcIds.get(i);

                                    // Creation of the
                                    // identifier associated
                                    // with the distance
                                    id = buildFid(arcId, processedDistance);
                                    // ResultStatsMap associated
                                    // with the arc
                                    ResultStatsMap resMap;
                                    if (bandAccepted) {
                                        resMap = statList.get(i);
                                    } else {
                                        resMap = statsMap;
                                    }

                                    try {
                                        // Writing of the result
                                        // for the selected
                                        // distance and Id
                                        concreteOperation.writeOutputObjects(trace,
                                                vulnerabilityObj, total, outFeatureName, arc, id,
                                                resMap.getStatsMap(), partner);
                                        // DEBUG: indication of
                                        // which arc is
                                        // calculated
                                        if (LOGGER.isDebugEnabled()) {
                                            LOGGER.debug("Raster=" + targetID + ", TILE=(" + x
                                                    + "," + y + ") Computed arc "
                                                    + arc.getAttribute(GEOID) + "for distance="
                                                    + processedDistance);
                                        }
                                    } catch (Exception e) {
                                        monitor.errors++;
                                        metadataHandler.logError(trace, monitor.getErrors(),
                                                "Raster=" + targetID + ", TILE=(" + x + "," + y
                                                        + ") Error writing objects on " + geoName,
                                                getError(e), 0);
                                        LOGGER.error("Raster=" + targetID + ", TILE=(" + x + ","
                                                + y + ") Error writing objects on " + geoName, e);
                                    }

                                    // Clearing of the
                                    // associated ResultStatsMap
                                    if (!resMap.isEmpty()) {
                                        resMap.clear();
                                    }
                                }
                            }
                        } catch (Exception e) {
                            monitor.errors++;
                            LOGGER.error("Raster=" + targetID + ", TILE=(" + x + "," + y
                                    + ") Error writing objects on " + geoName, e);
                        }
                    }

                    // At the end of the operation on this list
                    // all the geometries are cleared for the
                    // next
                    // cell.
                    arcList.clear();
                    arcIds.clear();
                    bufferList.clear();
                    featureCounter += temporaryCounter;
                }
            }
        }

        // Reset of the Loop Counter
        monitor.loopCounter = 0;
    }

    /**
     * This method calculates the vulnerability for the level 3
     * 
     * @param currentImage
     * @param currentBPT
     * @param keySet
     * @param targetID
     * @param bbox
     * @param outFeatureName
     * @param trace
     * @param vse
     * @param vulnerabilityObj
     * @param concreteOperation
     * @param monitor
     * @param allDistances
     * @param reportingLoopStep
     * @param geoName
     * @param partnerFilter
     * @param total
     * @throws IOException
     */
    private void vulnerabilityLevel3(RenderedImage currentImage,
            Map<Integer, TargetInfo> currentBPT, ConcurrentSkipListSet<BigDecimal> keySet,
            String targetID, Envelope2D bbox, String outFeatureName, int trace,
            VulnerabilityStatsEngine vse, OutputObject vulnerabilityObj,
            VulnerabilityOperation concreteOperation, Monitor monitor, List<Double> allDistances,
            int reportingLoopStep, String geoName, Filter partnerFilter, int total)
            throws IOException {

        // Creation of a List of features
        List<SimpleFeature> arcList = new ArrayList<SimpleFeature>();

        SimpleFeature inputFeature;
        // Setting of the input filter
        BigDecimal idCellStart = new BigDecimal(startOriginId);
        BigDecimal idCellStop = new BigDecimal(endOriginId);

        concreteOperation.setStartOriginId(idCellStart.longValue());
        concreteOperation.setEndOriginId(idCellStop.longValue());
        // Creation of the input filter used
        setInputFilter(concreteOperation
                .buildOriginFilterExtended(partner, total, null, bbox, null));

        // Empty map used for containing only the accepted
        // targets
        Map<Integer, TargetInfo> acceptedBands = new TreeMap<Integer, TargetManager.TargetInfo>();
        Map<Double, ResultStatsMap> statList = new TreeMap<Double, ResultStatsMap>();

        while ((inputFeature = readInputSorted()) != null) {

            // Selection of the id associated to the feature.
            BigDecimal arcId = ((BigDecimal) inputFeature.getAttribute(ID_GEO_ARCO));

            // Check if the feature has been already taken
            boolean notContained = keySet.add(arcId);
            if (!notContained) {
                monitor.loopCounter++;
                // loopCounter++;
                continue;
            }

            // For level 3, get all the arcs that intersect with
            // the current grid cell
            FeatureIterator<SimpleFeature> iterator = null;

            try {
                // Cell element
                Geometry cell = (Geometry) inputFeature.getDefaultGeometry();
                String linearGeoName = geoName.replace("pl", "ln");
                FeatureSource<SimpleFeatureType, SimpleFeature> reader = createInputReader(
                        dataStore, null, linearGeoName);
                // Iterator for selecting all the geometries
                // intersecting the cell

                Filter featureFilter = filterFactory.and(filterFactory.intersects(
                        filterFactory.property(getInputGeometryName(dataStore, linearGeoName)),
                        filterFactory.literal(cell)), partnerFilter);

                FeatureCollection<SimpleFeatureType, SimpleFeature> features = reader
                        .getFeatures(featureFilter);
                int featureSize = reader.getCount(new Query(linearGeoName));

                iterator = features.features();
                int featureCounter = 0;
                while (featureCounter < featureSize && iterator.hasNext()) {
                    // Temporary counter used for calculating only a fixed number of geometries for each time
                    int temporaryCounter = 0;

                    // Iteration on the image tile for searching
                    // all the geometries
                    while (temporaryCounter <= MAX_TEMP_CALC && iterator.hasNext()) {
                        SimpleFeature sf = (SimpleFeature) iterator.next();
                        // addition of the simple feature to the
                        // list
                        arcList.add(sf);
                        temporaryCounter++;
                    }

                    // BUFFER CALCULATION
                    // If almost an arc is present
                    if (arcList.size() > 0) {
                        // computeBuffersOnArcs
                        MultipleBufferMap mbm = vse.computeBuffersOnArcs(arcList, allDistances);

                        for (Double processedDistance : allDistances) {
                            // Update of the currentDistance variable for exception logging
                            monitor.setCurrentDistance(processedDistance);
                            // Creation of the ResultStatsMap for the selected distance if not present
                            if (!statList.containsKey(processedDistance)) {
                                statList.put(processedDistance,
                                        new ResultStatsMap(vulnerabilityCfg));
                            }
                            // Check if the distance is related
                            // to the selected target
                            acceptedBands = mapAcceptedBands(acceptedBands, currentBPT,
                                    processedDistance);
                            // Statistics computation

                            // The statistics are calculated
                            // only if almost one of the targets
                            // accepts the current distance
                            if (!acceptedBands.isEmpty()) {
                                vse.computeStats(mbm.getBuffersForDistance(processedDistance),
                                        currentImage, statList.get(processedDistance), false,
                                        acceptedBands);
                            }

                            acceptedBands.clear();
                        }
                    }
                    // At the end of the operation on this list
                    // all the geometries are cleared for the
                    // next
                    // group
                    arcList.clear();
                    featureCounter += temporaryCounter;
                }
            } catch (Exception e) {
                LOGGER.error("Raster=" + targetID + ", Error reading " + geoName, e);
                monitor.errors++;
                metadataHandler.logError(trace, monitor.getErrors(), "Raster=" + targetID
                        + ", Error reading " + geoName, getError(e), 0);
            } finally {
                if (iterator != null) {
                    iterator.close();
                }
            }
            // BUFFER CALCULATION
            // If almost an arc is present
            // Selection of the arc id
            monitor.setArcId(arcId.toString());
            try {
                int calculationErrors = 0;
                // Writing of the results on the DataBase
                calculationErrors = writeResultsOnDB(targetID, outFeatureName, trace,
                        monitor.getErrors(), vulnerabilityObj, concreteOperation, inputFeature,
                        allDistances, geoName, total, monitor.getArcId(), statList);
                monitor.setErrors(calculationErrors);
                // At the end of the operation on this list
                // all the Buffers are cleared for the next
                // cell
                statList.clear();

            } catch (Exception e) {
                monitor.errors++;
                LOGGER.error("Raster=" + targetID + ", Error writing objects on " + geoName, e);
            }
            // Update of the LoopCounter
            monitor.loopCounter++;
            // loopCounter++;

            // When a certain number of geometries are
            // calculated, a report is printed
            if (monitor.getLoopCounter() % reportingLoopStep == 0) {
                LOGGER.info("Raster=" + targetID + ", computed arcs FROM -"
                        + (monitor.getLoopCounter() - reportingLoopStep) + "- TO -"
                        + monitor.getLoopCounter() + "-");
            }
            // DEBUG: indication of which arc is calculated
            if (LOGGER.isDebugEnabled() && inputFeature != null) {
                LOGGER.debug("Raster=" + targetID + ", Computed cell "
                        + inputFeature.getAttribute(GEOID));
            }
        }
        // Reset of the Loop Counter
        monitor.loopCounter = 0;
    }

    /**
     * Private method used for preparing the vulnerability operation associated to the input write mode
     * 
     * @param writeMode
     * @param vulnerabilityObj
     * @return
     * @throws IOException
     */
    private VulnerabilityOperation prepareVulnerabilityOperation(String writeMode,
            OutputObject vulnerabilityObj) throws IOException {
        VulnerabilityOperation concreteOperation = VulnerabilityOperation
                .instantiateWriterFromString(writeMode);
        LOGGER.info("Using writer " + VulnerabilityOperation.class);
        concreteOperation.initFeature(vulnerabilityObj, partner);
        // Setup filtering
        concreteOperation.setStartOriginId(startOriginId);
        concreteOperation.setEndOriginId(endOriginId);
        concreteOperation.setPageNumber(pageNumber);
        concreteOperation.setTotPages(totPages);

        return concreteOperation;
    }

    public void removeFeatures(String writeMode, int aggregationLevel) throws IOException{
        if(writeMode.equalsIgnoreCase("PURGE_INSERT")){
            // Selection of the type name
            String outFeatureName = getTypeName(VULNERABILITY_TYPE_NAME, aggregationLevel);
            // Creation of a new Transaction
            Transaction transaction = new DefaultTransaction();
            try{
                // Preparing of the Purge_Insert operation which removes all the features already present
                OutputObject vulnerabilityObj = new OutputObject(dataStore, transaction,
                        outFeatureName, GEOID);        
                prepareVulnerabilityOperation(writeMode, vulnerabilityObj);
            }finally{
             // Closing Transaction
                transaction.close();
            }
        }
    }
    
    /**
     * Private method used for checking if the input feature has been already calculated.
     * 
     * @param targetID
     * @param skipArcs
     * @param outFeatureName
     * @param transaction
     * @param inputFeature
     * @param featureSize
     * @return
     * @throws IOException
     */
    private int checkInputFeature(String targetID, boolean skipArcs, String outFeatureName,
            Transaction transaction, SimpleFeature inputFeature, int featureSize)
            throws IOException {
        if (inputFeature != null && skipArcs
                && targetID.equalsIgnoreCase("NotHuman")) {
            // Selection of the id associated to the
            // feature.
            BigDecimal arcId = ((BigDecimal) inputFeature
                    .getAttribute(ID_GEO_ARCO));

            if (!FeatureLoaderUtils
                    .createFeatureSource(dataStore, transaction,
                            outFeatureName)
                    .getFeatures(
                            filterFactory.equals(
                                    filterFactory.property(GEOID),
                                    filterFactory.literal(arcId)))
                    .isEmpty()) {
                featureSize = 0;
            }
        }
        return featureSize;
    }

    /**
     * Private method which returns the Geometry list associated to the processed distance
     * 
     * @param bufferList
     * @param processedDistance
     * @return
     */
    private static List<Geometry> calculateGeometryList(List<MultipleBufferMap> bufferList,
            Double processedDistance) {
        List<Geometry> geometryList = new ArrayList<Geometry>();
        // Addition of the buffer
        // associated with the
        // selected distance and arc
        for (MultipleBufferMap mbm : bufferList) {

            // Use the cell for crop
            // the raster if the
            // aggregation level ==
            // 3, use the buffer
            // otherwise
            Geometry bufferArea = (Geometry) mbm
                    .getBuffersForDistance(
                            processedDistance).get(0);

            geometryList.add(bufferArea);
        }
        return geometryList;
    }

    /**
     * Private method for writing the results on the Database for the level 3
     * 
     * @param targetID
     * @param outFeatureName
     * @param trace
     * @param errors
     * @param vulnerabilityObj
     * @param concreteOperation
     * @param inputFeature
     * @param allDistances
     * @param geoName
     * @param total
     * @param idArco
     * @param statList
     * @return
     * @throws IOException
     */
    private int writeResultsOnDB(String targetID, String outFeatureName, int trace, int errors,
            OutputObject vulnerabilityObj, VulnerabilityOperation concreteOperation,
            SimpleFeature inputFeature, List<Double> allDistances, String geoName, int total,
            String idArco, Map<Double, ResultStatsMap> statList) throws IOException {
        // Iteration on all the buffers
        for (Double processedDistance : allDistances) {
            try {
                // Writing of the result for the
                // selected distance and Id
                concreteOperation.writeOutputObjects(trace,
                        vulnerabilityObj, total, outFeatureName,
                        inputFeature, buildFid(idArco, processedDistance), statList.get(processedDistance)
                                .getStatsMap(), partner);
            } catch (Exception e) {
                errors++;
                metadataHandler.logError(trace, errors, "Raster="
                        + targetID + ", Error writing objects on "
                        + geoName, getError(e), 0);
                LOGGER.error("Raster=" + targetID
                        + ", Error writing objects on " + geoName, e);
            }
        }
        return errors;
    }

    /**
     * Method which returns a map for all the accepted bands for the processed distance 
     * 
     * @param inputAcceptedBands
     * @param currentBPT
     * @param processedDistance
     * @return
     */
    private Map<Integer, TargetInfo> mapAcceptedBands(Map<Integer, TargetInfo> inputAcceptedBands, Map<Integer, TargetInfo> currentBPT,
            Double processedDistance) {
        Map<Integer, TargetInfo> acceptedBands;
        // If the Map is already present, it is cleared and reused
        if(inputAcceptedBands!=null){
            inputAcceptedBands.clear();
            acceptedBands = inputAcceptedBands;
        }else{// Else a new object is created
            acceptedBands = new TreeMap<Integer, TargetManager.TargetInfo>();
        }
        // Set of all the bands
        Set<Integer> keys = currentBPT.keySet();
        // Cycle on all the targets
        for (int band : keys) {
            // Selection of the
            // TargetInfo
            TargetInfo infoPerBand = currentBPT.get(band);
            // TargetManager associated
            TargetManager mng = infoPerBand.getManager();
            // If the distance is
            // related to the target,
            // then it is added to the
            // map of the accepted band
            if (mng.isDistanceRelatedToTarget(processedDistance)) {
                acceptedBands.put(band, infoPerBand);
            }
        }
        return acceptedBands;
    }

    /**
     * Build the Fid associated to the arcId
     * @param idArco
     * @param el
     * @return
     */
    private static String buildFid(String idArco, Double el) {
        return idArco + "." + el.intValue();
    }

    /**
     * Method used for merging the input Rasters into a 2 images, one for human targets and the other for not human targets
     * 
     * @param humanTargets
     * @param notHumanTargets
     * @param bandPerTargetH
     * @param bandPerTargetNH
     * @throws IOException
     */
    public RenderedImage[] rasterCalculation(Map<Integer, TargetInfo> bandPerTargetH,
            Map<Integer, TargetInfo> bandPerTargetNH) throws IOException {
        RenderedImage humanTargets = null;
        RenderedImage notHumanTargets = null;
        String basePath = System.getProperty(RASTER_PATH_PROP, "");
        if (!basePath.equals("")) {
            basePath = basePath + File.separator + codicePartner;
        }

        Map vulnerabilityConf = (Map) readResourceFromXML("/vulnerability.xml");

        VulnerabilityStatsEngine vsengine = new VulnerabilityStatsEngine(basePath,
                vulnerabilityConf, dataStore, DISTANCE_TYPE_NAME, pixelArea);

        Map<String, TargetInfo> targetInfo = vsengine.getTargetInfo();

        /*
         * Creation of 2 images: one for the HUMAN TARGETS and the other for NOT HUMAN TARGETS
         */
        // List of Human Targets
        List<RenderedImage> humanList = new ArrayList<RenderedImage>();

        // List of Not Human Targets
        List<RenderedImage> notHumanList = new ArrayList<RenderedImage>();

        // List of Human Targets bounds
        Rectangle humanBounds = new Rectangle();

        // List of Not Human Targets bounds
        Rectangle notHumanBounds = new Rectangle();

        // Counters indicating which band is associated to the TargetInfo and
        // Image
        int humanBandCounter = 0;
        int notHumanBandCounter = 0;

        // Iterator on all the targets
        Iterator<String> rasterIter = targetInfo.keySet().iterator();

        // HP 1 ALL THE TARGETS HAVE THE SAME NODATA
        // HP 2 ALL THE TARGETS HAVE THE SAME WORLD2GRID TRANSFORMATION
        // HP 3 ALL THE TARGETS HAVE THE SAME DIMENSIONS

        while (rasterIter.hasNext()) {
            // save the ID of this target
            String targetID = rasterIter.next();

            // Load the target manager, init its status and check if the actual
            // distance is a valid distance for it
            TargetInfo info = targetInfo.get(targetID);

            TargetManager manager = info.getManager();

            // Image associated to the current target
            RenderedImage newImage = info.getRaster();

            int imgDataType = newImage.getSampleModel().getDataType();

            if (newImage != null) {
                // If the target is human
                if (manager.isHumanTarget()) {

                    if (imgDataType != DataBuffer.TYPE_FLOAT) {
                        System.out.println("Wrong data type");
                    }

                    // Addition of the TargetInfo of this target
                    bandPerTargetH.put(humanBandCounter, info);
                    // Update of the bandCounter
                    humanBandCounter++;
                    // Addition of the image to the associated list
                    humanList.add(newImage);
                    // Addition of the human bounds
                    humanBounds = humanBounds.union(new Rectangle(newImage.getMinX(), newImage
                            .getMinY(), newImage.getWidth(), newImage.getHeight()));
                    // If the target is not human
                } else {

                    if (imgDataType != DataBuffer.TYPE_BYTE) {
                        System.out.println("Wrong data type");
                    }

                    // Addition of the TargetInfo of this target
                    bandPerTargetNH.put(notHumanBandCounter, info);
                    // Update of the bandCounter
                    notHumanBandCounter++;
                    // Addition of the image to the associated list
                    notHumanList.add(newImage);
                    // Addition of the not human bounds
                    notHumanBounds = notHumanBounds.union(new Rectangle(newImage.getMinX(),
                            newImage.getMinY(), newImage.getWidth(), newImage.getHeight()));
                }
            }
        }

        Rectangle union = notHumanBounds.union(humanBounds);

        // List of Human Targets
        List<RenderedImage> newHumanList = new ArrayList<RenderedImage>();

        // List of Not Human Targets
        List<RenderedImage> newNotHumanList = new ArrayList<RenderedImage>();

        // Not Human bbox border extension
        for (RenderedImage image : notHumanList) {
            int leftPad = union.x - image.getMinX();
            int topPad = union.y - image.getMinY();
            int rightPad = union.width - image.getWidth() - leftPad;
            int bottomPad = union.height - image.getHeight() - topPad;
            newNotHumanList.add(BorderDescriptor.create(image, leftPad, rightPad, topPad,
                    bottomPad, type, VulnerabilityUtils.NO_TILE_CACHE));
        }

        // Human bbox border extension
        for (RenderedImage image : humanList) {
            int leftPad = union.x - image.getMinX();
            int topPad = union.y - image.getMinY();
            int rightPad = union.width - image.getWidth() - leftPad;
            int bottomPad = union.height - image.getHeight() - topPad;
            newHumanList.add(BorderDescriptor.create(image, leftPad, rightPad, topPad, bottomPad,
                    type, VulnerabilityUtils.NO_TILE_CACHE));
        }

        // BandMerge of the images
        RenderedImage[] imagesHuman = new RenderedImage[newHumanList.size()];
        RenderedImage[] imagesNotHuman = new RenderedImage[newHumanList.size()];

        humanTargets = BandMergeDescriptor.create(null, 0, VulnerabilityUtils.NO_TILE_CACHE,
                newHumanList.toArray(imagesHuman));

        notHumanTargets = BandMergeDescriptor.create(null, 0, VulnerabilityUtils.NO_TILE_CACHE,
                newNotHumanList.toArray(imagesNotHuman));

        // cache the final image
        humanTargets = NullDescriptor.create(humanTargets, new RenderingHints(JAI.KEY_TILE_CACHE,
                JAI.getDefaultInstance().getTileCache()));
        // ((RenderedOp)humanTargets).getTiles();
        notHumanTargets = NullDescriptor.create(notHumanTargets, new RenderingHints(
                JAI.KEY_TILE_CACHE, JAI.getDefaultInstance().getTileCache()));

        // Clearing of the initial lists
        notHumanList.clear();
        humanList.clear();

        return new RenderedImage[] { humanTargets, notHumanTargets };

    }

    /**
     * Method used for extracting the cells from this vulnerability object. If a cell ID is set and skipArcs is true, then only the cells which are
     * greater than that selected are used.
     * 
     * @param cellStart
     * @param skipArcs
     * @return
     * @throws IOException
     */
    public FeatureCollection<SimpleFeatureType, SimpleFeature> geometryIDList(String cellStart,
            boolean skipArcs) throws IOException {

        int aggregationLevel = 3;
        // setup geo input / output object
        String geoName = getTypeName(GEO_TYPE_NAME, aggregationLevel);
        geoName = geoName.replace("ln", "pl");
        createInputReader(dataStore, null, geoName);

        // Setting of the input filter
        // Simple filter on the partner

        Filter filter = filterFactory.equals(filterFactory.property(PARTNER_FIELD),
                filterFactory.literal(partner));
        // Needed if the user restart the computation from the cellStart id
        if (skipArcs && cellStart != null) {
            filter = filterFactory.and(
                    filter,
                    filterFactory.greaterOrEqual(filterFactory.property(GEOID),
                            filterFactory.literal(cellStart)));
        }

        setInputFilter(filter);

        FeatureCollection<SimpleFeatureType, SimpleFeature> cells = readCollectionSorted();

        return cells;
    }
    
    /**
     * Helper class for storing information used for reporting exceptions
     */    
    static class Monitor{
        /** Counter indicating how many Features have been calculated*/
        private int loopCounter = 0;
        /** Counter indicating the number of errors returned*/
        private int errors = 0;
        /** Double indicating the current distance calculated when the calculations have been stopped*/
        private double currentDistance = 0;
        /** String containing the name of the arc on which the calculations have been stopped*/
        private String arcId = "";
        
        public int getLoopCounter() {
            return loopCounter;
        }

        public void setLoopCounter(int loopCounter) {
            this.loopCounter = loopCounter;
        }

        public int getErrors() {
            return errors;
        }

        public void setErrors(int errors) {
            this.errors = errors;
        }

        public String getArcId() {
            return arcId;
        }

        public void setArcId(String arcId) {
            this.arcId = arcId;
        }

        public double getCurrentDistance() {
            return currentDistance;
        }

        public void setCurrentDistance(double currentDistance) {
            this.currentDistance = currentDistance;
        }
    }
}
