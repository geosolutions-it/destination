/*
 *  Copyright (C) 2007-2012 GeoSolutions S.A.S.
 *  http://www.geo-solutions.it
 *
 *  GPLv3 + Classpath exception
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.geosolutions.geobatch.destination.vulnerability;

import it.geosolutions.geobatch.destination.common.InputObject;
import it.geosolutions.geobatch.destination.common.OutputObject;
import it.geosolutions.geobatch.destination.ingestion.MetadataIngestionHandler;
import it.geosolutions.geobatch.destination.vulnerability.TargetManager.TargetInfo;
import it.geosolutions.geobatch.flow.event.ProgressListenerForwarder;
import java.awt.image.RenderedImage;
import java.io.File;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.media.jai.operator.BandMergeDescriptor;
import org.geotools.data.DefaultTransaction;
import org.geotools.data.FeatureSource;
import org.geotools.data.Transaction;
import org.geotools.feature.FeatureIterator;
import org.geotools.geometry.DirectPosition2D;
import org.geotools.geometry.Envelope2D;
import org.geotools.jdbc.JDBCDataStore;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;
import org.opengis.filter.Filter;
import org.opengis.geometry.BoundingBox;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.opengis.referencing.operation.MathTransform;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.vividsolutions.jts.geom.Geometry;
/**
 * This class is the entry point for the vulnerability process (method computeVulnerability) and it implements the computation's main loop 
 * 
 * @author DamianoG
 * @author Daniele Romagnoli, GeoSolutions SAS
 */
public class VulnerabilityComputation extends InputObject {

    private final static Logger LOGGER = LoggerFactory.getLogger(VulnerabilityComputation.class);

    private static Pattern TYPE_NAME_PARTS = Pattern
			.compile("^([A-Z]{2})_([A-Z]{1})_([A-Za-z]+)_([0-9]{8})$");
    
    public static String GEO_TYPE_NAME = "siig_geo_ln_arco_X";
    
    public static String VULNERABILITY_TYPE_NAME = "siig_t_vulnerabilita_X";
    private static String DISTANCE_TYPE_NAME = "siig_d_distanza";
    private static String ID_GEO_ARCO = "id_geo_arco";
    public static String PARTNER_FIELD = "fk_partner";
    public static String GEOID = "id_geo_arco";
    
    public final static String RASTER_PATH_PROP = "SIIG_RASTERS_PATH";
    
    private Long startOriginId; 
    private Long endOriginId;
    private Long totPages; 
    private Long pageNumber;
    
    private int pixelArea;
    
    private Map vulnerabilityCfg;
    
    
    String codicePartner;
    int partner;
    
    
    /**
     * @param startOriginId the startOriginId to set
     */
    public void setStartOriginId(Long startOriginId) {
        this.startOriginId = startOriginId;
    }

    /**
     * @param endOriginId the endOriginId to set
     */
    public void setEndOriginId(Long endOriginId) {
        this.endOriginId = endOriginId;
    }

    /**
     * @param pixelArea the pixelArea to set
     */
    public void setPixelArea(int pixelArea) {
        this.pixelArea = pixelArea;
    }

    /**
     * @param totPages the totPages to set
     */
    public void setTotPages(Long totPages) {
        this.totPages = totPages;
    }

    /**
     * @param pageNumber the pageNumber to set
     */
    public void setPageNumber(Long pageNumber) {
        this.pageNumber = pageNumber;
    }

    /**
     * @param inputTypeName
     * @param listenerForwarder
     */
    public VulnerabilityComputation(String inputTypeName,
            ProgressListenerForwarder listenerForwarder,
			MetadataIngestionHandler metadataHandler, JDBCDataStore dataStore) {
        super(inputTypeName, listenerForwarder, metadataHandler, dataStore);
        // default area
        pixelArea = 100;
    }

    @Override
    protected boolean parseTypeName(String typeName) {
        Matcher m = TYPE_NAME_PARTS.matcher(typeName);
        if(m.matches()) {
			// partner alphanumerical abbreviation (from siig_t_partner)
			codicePartner = m.group(1);
			// partner numerical id (from siig_t_partner)
			partner = Integer.parseInt(partners.get(codicePartner).toString());			
			
			return true;
		}
        return false;
    }

    private String getTypeName(String typeName, int aggregationLevel) {
        return typeName.replace("X", aggregationLevel + "");
    }

    /**
     * Compute the vulnerability for each arc. The Algorithm is:
     * 
     * ForEach(target)
     *    buffers = computeBuffers(allDistance, arc);
     *    ForEach(distance)
     *          if(!isAccepted(distance,target))
     *                  saveOnDB(0,arc,target,distance)
     *                  continue;
     *          sum = computeSum(buffer, target);
     *          ForEach(arc)                 
     *                  saveOnDB(sum,arc,target,distance);
     * 
     * 
     * @param datastoreParams
     * @param crs
     * @param aggregationLevel
     * @throws IOException
     */
    public void computeVulnerability(CoordinateReferenceSystem crs, int aggregationLevel, String writeMode, String closePhase) throws IOException {

        reset();
        if (isValid()) {            

            crs = checkCrs(crs);

            String outFeatureName = getTypeName(VULNERABILITY_TYPE_NAME, aggregationLevel);

            int process = -1;
            int trace = -1;
            int errors = 0;
            long otherErrors = 0;

            // existing process
            MetadataIngestionHandler.Process importData = getProcessData();
            process = importData.getId();
            trace = importData.getMaxTrace();
            errors = importData.getMaxError();
            int startErrors = errors;
            
            if(process == -1) {
                LOGGER.error("Cannot find process for input file");
		throw new IOException("Cannot find process for input file");
            } 			            

            //
            // Load All needed resources: properties files, Rendered Images, GeotifReaders 
            //
            vulnerabilityCfg = (Map) readResourceFromXML("/vulnerability.xml");
            String basePath = System.getProperty(RASTER_PATH_PROP, "");
            if(!basePath.equals("")) {
            	basePath = basePath + File.separator + codicePartner;
            }
            VulnerabilityStatsEngine vse = new VulnerabilityStatsEngine(basePath, vulnerabilityCfg, dataStore, DISTANCE_TYPE_NAME, pixelArea);
            
            ResultStatsMap statsMap = new ResultStatsMap(vulnerabilityCfg);

            //Setup the OutputObject (in thet case the vulnerability table) remove old values for the partner and detect the max id
            Transaction transaction = new DefaultTransaction();
            OutputObject vulnerabilityObj = new OutputObject(dataStore, transaction,
                    outFeatureName, GEOID);

            //
            // Load the concrete operation (Insert or PurgeInsert or Update)
            //
            VulnerabilityOperation concreteOperation = VulnerabilityOperation.instantiateWriterFromString(writeMode);
            LOGGER.info("Using writer " + VulnerabilityOperation.class);
            concreteOperation.initFeature(vulnerabilityObj, partner);
            // Setup filtering
            concreteOperation.setStartOriginId(startOriginId);
            concreteOperation.setEndOriginId(endOriginId);
            concreteOperation.setPageNumber(pageNumber);
            concreteOperation.setTotPages(totPages);
            
            //
            // Start the vulnerability Computation
            //
            try {
                SimpleFeature inputFeature = null;
                int loopCounter = 0;
                List<Double> allDistances = vse.getDistances();
                final int reportingLoopStep = allDistances.size() > 10 ? 50 : 100;
                
                // setup geo input / output object
		String geoName = getTypeName(GEO_TYPE_NAME, aggregationLevel);
		if(aggregationLevel == 3){
		    geoName = geoName.replace("ln", "pl");
                }
                createInputReader(dataStore, null, geoName);
                
    		Filter partnerFilter = 
    			filterFactory.equals(filterFactory.property(PARTNER_FIELD),
                        filterFactory.literal(partner));
    		setInputFilter(partnerFilter);
    		
    		int total = getImportCount();
    			
    		//setInputFilter(concreteOperation.buildOriginFilter(partner, total));    		   		
    		
                // calculates total objects to import                
                LOGGER.info("import count: " + total);
                Map<String, TargetInfo> targetInfo = vse.getTargetInfo();
                
                LOGGER.info("Start computation: ThreadName: " + Thread.currentThread().getName() + " - startOriginId: " + startOriginId + " - endOriginId: " + endOriginId);
                String targetID = null;
                String idArco = null; 
                Double currentDistance = null;
 
                /*
                 * Creation of 2 images: one for the HUMAN TARGETS and the other for NOT HUMAN TARGETS
                 */       
                // Image associated with the human targets
                RenderedImage humanTargets = null;
                
                // Image associated with the not human targets
                RenderedImage notHumanTargets = null;
                
                // Map which contains the informations for each human target
                Map<Integer,TargetInfo> bandPerTargetH = new TreeMap<Integer, TargetManager.TargetInfo>();
                
                // Map which contains the informations for each not human target
                Map<Integer,TargetInfo> bandPerTargetNH = new TreeMap<Integer, TargetManager.TargetInfo>();
                
                // Counters indicating which band is associated to the TargetInfo and Image
                int humanBandCounter = 0;                
                int notHumanBandCounter = 0;
                
                // Iterator on all the targets
                Iterator rasterIter = targetInfo.keySet().iterator();
                
                
                // HP 1 ALL THE TARGETS HAVE THE SAME NODATA
                // HP 2 ALL THE TARGETS HAVE THE SAME WORLD2GRID TRANSFORMATION
                // HP 3 ALL THE TARGETS HAVE THE SAME DIMENSIONS
                
                while (rasterIter.hasNext()) {
                    // save the ID of this target 
                    targetID = (String) rasterIter.next();

                    // Load the target manager, init its status and check if the actual distance is a valid distance for it
                    TargetInfo info = targetInfo.get(targetID);                   
                    
                    // Image associated to the current target
                    RenderedImage newImage = info.getRaster();
                    
                    if (newImage != null) {
                        // If the target is human
                        if (info.getId() == TargetPropertiesLoader.UMANI_PREFIX.toString()) {

                            // Addition of the TargetInfo of this target
                            bandPerTargetH.put(humanBandCounter, info);
                            // Update of the bandCounter
                            humanBandCounter++;
                            
                            // If the image is the first, then the final image is equal to that
                            // else, it is added as an additional band
                            if (humanTargets == null) {
                                humanTargets = newImage;
                            } else {
                                humanTargets = BandMergeDescriptor.create(humanTargets, newImage,
                                        null);
                            }
                            // If the target is not human
                        } else {
                            // Addition of the TargetInfo of this target
                            bandPerTargetNH.put(notHumanBandCounter, info);
                            // Update of the bandCounter
                            notHumanBandCounter++;

                            // If the image is the first, then the final image is equal to that
                            // else, it is added as an additional band
                            if (notHumanTargets == null) {
                                notHumanTargets = newImage;
                            } else {
                                notHumanTargets = BandMergeDescriptor.create(notHumanTargets,
                                        newImage, null);
                            }
                        }
                    }
                }

                // Current image used in calculation
                RenderedImage currentImage;
                
                // Current TargetInfo Map used
                Map<Integer,TargetInfo> currentBPT;
                
                // Elaboration on both the 2 images
                for(int target = 0; target < 2; target++){
                    
                    // Human targets
                    if(target == 0){
                        
                        currentImage = humanTargets;
                        
                        currentBPT = bandPerTargetH;                        
                    // Not Human targets
                    }else{
                        
                        currentImage = notHumanTargets;
                        
                        currentBPT = bandPerTargetNH;                                                
                    }
                    
                    try {
                        // Creation of a List of features
                        List<SimpleFeature> arcList = new ArrayList<SimpleFeature>();

                        // Creation of a set containing all of the geometry keys
                        Set<BigDecimal> keySet = new LinkedHashSet<BigDecimal>();                        
                        
                        if (aggregationLevel != 3) {     
                            // Creation of a list of the arc Ids
                            List<String> arcIds = new ArrayList<String>();
                            // Load the Transformation associated with the selected target and calculate the inverse
                            TargetInfo firstInfo = currentBPT.get(0);                          
                            MathTransform w2g = firstInfo.getWorld2Grid();
                            MathTransform g2w = w2g.inverse();
                            // Load the target dimensions for modifying the spatial filter
                            int startX = currentImage.getMinX();
                            int startY = currentImage.getMinY();
                            int height = currentImage.getHeight();
                            int width = currentImage.getWidth();
                            // Increment Factor used for iterate on all the image bounds
                            int increment = (Math.min(height, width) / 10);

                            int maxX = startX + increment - 1;
                            int maxY = startY + increment - 1;

                            int minX = startX;
                            int minY = startY;
                            // Iteration on image tiles
                            while (maxX < width + increment) {
                                while (maxY < height + increment) {
                                    // For each tile, the points are transformed in the world crs
                                    // Source Coordinates
                                    double[] srcPts = new double[] { minX, minY, maxX, maxY };
                                    // World Coordinates
                                    double[] dstPts = new double[srcPts.length];
                                    // Coordinates transformation
                                    g2w.transform(srcPts, 0, dstPts, 0, 2);
                                    // Creation of the BoundingBox associated with the selected tile
                                    DirectPosition2D minXY = new DirectPosition2D(dstPts[0],
                                            dstPts[1]);
                                    DirectPosition2D maxXY = new DirectPosition2D(dstPts[2],
                                            dstPts[3]);
                                    // Creation of the bounding box associated to this image tile
                                    BoundingBox bbox = new Envelope2D(minXY, maxXY);
                                    // Creation of a spatial filter for taking only the features associated
                                    // to the selected bounding box
                                    setInputFilter(concreteOperation
                                            .buildOriginFilter(partner, total, bbox));
                                    //Iteration on the image tile for searching all the geometries
                                    while ((inputFeature = readInput()) != null) {
                                        // Selection of the id associated to the feature.
                                        BigDecimal arcId = ((BigDecimal) inputFeature
                                                .getAttribute(ID_GEO_ARCO));
                                        // Check if the feature has been already taken
                                        boolean notContained = keySet.add(arcId);
                                        if (notContained) {
                                            arcList.add(inputFeature);
                                            // Selection of the arc id
                                            idArco = arcId.toString();
                                            // Update of the arc id list 
                                            arcIds.add(idArco);                                          
                                            // Update of the logger in debug
                                            if (LOGGER.isDebugEnabled() && inputFeature != null) {
                                                LOGGER.debug("Computing arc " + inputFeature.getID());
                                            }
                                        }
                                    }
                                    // INPUT READER CLOSURE
                                    try{
                                        closeInputReader();
                                    }catch(Exception e){
                                        errors++;
                                        metadataHandler.logError(trace, errors,
                                                "Error closing inputReader", getError(e),
                                                0);
                                        LOGGER.error("Error closing inputReader", e);
                                    }
                                    // BUFFER CALCULATION
                                    
                                    // If almost an arc is present
                                    int arcSize = arcList.size();
                                    
                                    if(arcSize > 0) {                                     
                                                                                
                                        String id = null;
                                        
                                        // Iteration on all the buffers
                                        for (Double processedDistance : allDistances) {                                            

                                           // Check if the distance is related to the selected target
                                           // Empty map used for containing only the accepted targets
                                           Map<Integer,TargetInfo> acceptedBands = new TreeMap<Integer, TargetManager.TargetInfo>();
                                           // Set of all the bands
                                           Set<Integer> keys = currentBPT.keySet();
                                           // Cycle on all the targets
                                           for(int band : keys){
                                               // Selection of the TargetInfo
                                               TargetInfo infoPerBand = currentBPT.get(band);
                                               // TargetManager associated
                                               TargetManager mng = infoPerBand.getManager();
                                               // If the distance is related to the target, then it is added to the map of the accepted band
                                               if (mng.isDistanceRelatedToTarget(processedDistance)) {
                                                   acceptedBands.put(band, infoPerBand);
                                               }                                               
                                           }                                                                                 
                                            // Statistical computation
                                           
                                           // The statistics are calculated only if almost one of the targets accepts the current distance
                                           if(!acceptedBands.isEmpty()){
                                               vse.computeStats(arcList, currentImage, statsMap, false, acceptedBands);
                                           }                                                                                                                                               
                                           // Iteration on all the geometries list
                                            for(int i = 0; i < arcSize; i++){
                                                // Update of the Loop Counter
                                                loopCounter++;
                                                // When a certain number of geometries are calculated, a report is printed
                                                if (loopCounter % reportingLoopStep == 0) {
                                                    LOGGER.info("computed arcs FROM -" + (loopCounter - 100)
                                                            + "- TO -" + loopCounter + "-");
                                                }
                                                // Selection of the arc
                                                SimpleFeature arc = arcList.get(i);
                                                // Selection of the arcId
                                                String arcId = arcIds.get(i);
                                                
                                                // Creation of the identifier associated with the distance
                                                id = buildFid(arcId, processedDistance);
                                                // DEBUG: indication of which arc is calculated
                                                if (LOGGER.isDebugEnabled()) {
                                                    LOGGER.debug("Computing arc " + arc.getID());
                                                }
                                                
                                                try {
                                                    // Writing of the result for the selected distance and Id
                                                    concreteOperation.writeOutputObjects(trace,
                                                            vulnerabilityObj, total, outFeatureName,
                                                            arc, id, statsMap.getStatsMap(), partner);
                                                } catch (Exception e) {
                                                    errors++;
                                                    metadataHandler.logError(trace, errors,
                                                            "Error writing objects on " + geoName, getError(e),
                                                            0);
                                                    LOGGER.error("Error writing objects on " + geoName, e);
                                                }
                                            }     
                                        }
                                        // At the end of the operation on this list
                                        // all the geometries are cleared for the next 
                                        // cell.
                                        arcList.clear();
                                        arcIds.clear();                                        
                                    }
                                    // Update on the Y position
                                    minY += increment;
                                    maxY += increment;
                                }
                                // Restart the computation on the Y position
                                maxY = startY + increment - 1;
                                minY = startY;
                                // Update on the X position
                                minX += increment;
                                maxX += increment;
                            }
                            
                        } else {
                            // Setting of the input filter
                            setInputFilter(concreteOperation
                                    .buildOriginFilter(partner, total, null));

                            while ((inputFeature = readInput()) != null) {

                                // For level 3, get all the arcs that intersect with the current grid cell
                                FeatureIterator<SimpleFeature> iterator = null;
                                try {
                                    // Cell element
                                    Geometry cell = (Geometry) inputFeature.getDefaultGeometry();
                                    String linearGeoName = geoName.replace("pl", "ln");
                                    FeatureSource<SimpleFeatureType, SimpleFeature> reader = createInputReader(
                                            dataStore, null, linearGeoName);
                                    // Iterator for selecting all the geometries intersecting the cell
                                    iterator = reader.getFeatures(
                                            filterFactory.and(filterFactory.intersects(
                                                    filterFactory.property(getInputGeometryName(
                                                            dataStore, linearGeoName)),
                                                    filterFactory.literal(cell)), partnerFilter))
                                            .features();
                                    while (iterator.hasNext()) {
                                        SimpleFeature sf = (SimpleFeature) iterator.next();
                                        // Selection of the id associated to the feature.
                                        BigDecimal arcId = ((BigDecimal) sf.getAttribute(ID_GEO_ARCO));
                                        // Check if the feature has been already taken
                                        boolean notContained = keySet.add(arcId);
                                        if (notContained) {
                                            arcList.add(sf);
                                        }
                                    }
                                } catch (Exception e) {
                                    LOGGER.error("Error reading " + geoName, e);
                                    errors++;
                                    metadataHandler.logError(trace, errors, "Error reading "
                                            + geoName, getError(e), 0);
                                } finally {
                                    if (iterator != null) {
                                        iterator.close();
                                    }
                                }
                                // BUFFER CALCULATION
                                // Selection of the arc id
                                idArco = ((BigDecimal) inputFeature.getAttribute(ID_GEO_ARCO)).toString();
                                // If almost an arc is present
                                if(arcList.size() > 0) {                                     
                                    // computeBuffersOnArcs                        
                                    MultipleBufferMap mbm = vse.computeBuffersOnArcs(arcList, allDistances);
                                    
                                    String id = null;
                                    
                                    // Iteration on all the buffers
                                    for (Double processedDistance : allDistances) {
                                        // Check if the distance is related to the selected target
                                        // Empty map used for containing only the accepted targets
                                        Map<Integer,TargetInfo> acceptedBands = new TreeMap<Integer, TargetManager.TargetInfo>();
                                        // Set of all the bands
                                        Set<Integer> keys = currentBPT.keySet();
                                        // Cycle on all the targets
                                        for(int band : keys){
                                            // Selection of the TargetInfo
                                            TargetInfo infoPerBand = currentBPT.get(band);
                                            // TargetManager associated
                                            TargetManager mng = infoPerBand.getManager();
                                            // If the distance is related to the target, then it is added to the map of the accepted band
                                            if (mng.isDistanceRelatedToTarget(processedDistance)) {
                                                acceptedBands.put(band, infoPerBand);
                                            }                                               
                                        }                                        
                                        // Creation of the identifier associated with the distance
                                      id = buildFid(idArco, processedDistance);
                                      
                                      // Statistics computation
                                      
                                      // The statistics are calculated only if almost one of the targets accepts the current distance
                                      if(!acceptedBands.isEmpty()){
                                          vse.computeStats(mbm.getBuffersForDistance(processedDistance), currentImage, statsMap, false, acceptedBands);
                                      }                                                                         
                                      try {
                                          // Writing of the result for the selected distance and Id
                                          concreteOperation.writeOutputObjects(trace,
                                                  vulnerabilityObj, total, outFeatureName,
                                                  inputFeature, id, statsMap.getStatsMap(), partner);
                                      } catch (Exception e) {
                                          errors++;
                                          metadataHandler.logError(trace, errors,
                                                  "Error writing objects on " + geoName, getError(e),
                                                  0);
                                          LOGGER.error("Error writing objects on " + geoName, e);
                                      }                                    
                                    }
                                    // At the end of the operation on this list
                                    // all the geometries are cleared for the next 
                                    // cell
                                    arcList.clear();
                                }
                                // Update of the LoopCounter
                                loopCounter++;
                                // When a certain number of geometries are calculated, a report is printed
                                if (loopCounter % reportingLoopStep == 0) {
                                    LOGGER.info("computed arcs FROM -" + (loopCounter - 100)
                                            + "- TO -" + loopCounter + "-");
                                }
                                // DEBUG: indication of which arc is calculated
                                if (LOGGER.isDebugEnabled() && inputFeature != null) {
                                    LOGGER.debug("Computing arc " + inputFeature.getID());
                                }                                
                            } 
                        }
                    } catch (Exception e) {
                        errors++;
                        metadataHandler.logError(trace, errors,
                                "Error occurred on raster: " + targetID + " for distance "
                                        + currentDistance + " on arc:" + idArco,
                                getError(e), 0);
                        LOGGER.error("Error occurred on raster: " + targetID
                                + " for distance " + currentDistance + " on arc:" + idArco
                                + "\n" + e.getMessage(), e);
                    }finally{
                        try{
                            closeInputReader();
                        }catch(Exception e){
                            errors++;
                            metadataHandler.logError(trace, errors,
                                    "Error closing inputReader", getError(e),
                                    0);
                            LOGGER.error("Error closing inputReader", e);
                        }                       
                    }                     
                }
//                while (rasterIter.hasNext()) {
//                    // save the ID of this target
//                    targetID = (String) rasterIter.next();
//
//                    // Load the target manager, init its status and check if the actual distance is a valid distance for it
//                    TargetInfo info = targetInfo.get(targetID);
//                    TargetManager targetManager = info.getManager();
//                    
//                    try {
//                        // Creation of a List of features
//                        List<SimpleFeature> arcList = new ArrayList<SimpleFeature>();
//
//                        // Creation of a set containing all of the geometry keys
//                        Set<BigDecimal> keySet = new LinkedHashSet<BigDecimal>();
//                        
//                        // Load the image associated with the target
//                        RenderedImage targetImg = info.getRaster();
//                        
//                        if (aggregationLevel != 3) {     
//                            // Creation of a list of the arc Ids
//                            List<String> arcIds = new ArrayList<String>();
//                            // Load the Transformation associated with the selected target and calculate the inverse
//                            MathTransform w2g = info.getWorld2Grid();
//                            MathTransform g2w = w2g.inverse();
//                            // Load the target dimensions for modifying the spatial filter
//                            int startX = targetImg.getMinX();
//                            int startY = targetImg.getMinY();
//                            int height = targetImg.getHeight();
//                            int width = targetImg.getWidth();
//                            // Increment Factor used for iterate on all the image bounds
//                            int increment = (Math.min(height, width) / 10);
//
//                            int maxX = startX + increment - 1;
//                            int maxY = startY + increment - 1;
//
//                            int minX = startX;
//                            int minY = startY;
//                            // Iteration on image tiles
//                            while (maxX < width + increment) {
//                                while (maxY < height + increment) {
//                                    // For each tile, the points are transformed in the world crs
//                                    // Source Coordinates
//                                    double[] srcPts = new double[] { minX, minY, maxX, maxY };
//                                    // World Coordinates
//                                    double[] dstPts = new double[srcPts.length];
//                                    // Coordinates transformation
//                                    g2w.transform(srcPts, 0, dstPts, 0, 2);
//                                    // Creation of the BoundingBox associated with the selected tile
//                                    DirectPosition2D minXY = new DirectPosition2D(dstPts[0],
//                                            dstPts[1]);
//                                    DirectPosition2D maxXY = new DirectPosition2D(dstPts[2],
//                                            dstPts[3]);
//                                    // Creation of the bounding box associated to this image tile
//                                    BoundingBox bbox = new Envelope2D(minXY, maxXY);
//                                    // Creation of a spatial filter for taking only the features associated
//                                    // to the selected bounding box
//                                    setInputFilter(concreteOperation
//                                            .buildOriginFilter(partner, total, bbox));
//                                    //Iteration on the image tile for searching all the geometries
//                                    while ((inputFeature = readInput()) != null) {
//                                        // Selection of the id associated to the feature.
//                                        BigDecimal arcId = ((BigDecimal) inputFeature
//                                                .getAttribute(ID_GEO_ARCO));
//                                        // Check if the feature has been already taken
//                                        boolean notContained = keySet.add(arcId);
//                                        if (notContained) {
//                                            arcList.add(inputFeature);
//                                            // Selection of the arc id
//                                            idArco = arcId.toString();
//                                            // Update of the arc id list 
//                                            arcIds.add(idArco);                                          
//                                            // Update of the logger in debug
//                                            if (LOGGER.isDebugEnabled() && inputFeature != null) {
//                                                LOGGER.debug("Computing arc " + inputFeature.getID());
//                                            }
//                                        }
//                                    }
//                                    // INPUT READER CLOSURE
//                                    try{
//                                        closeInputReader();
//                                    }catch(Exception e){
//                                        errors++;
//                                        metadataHandler.logError(trace, errors,
//                                                "Error closing inputReader", getError(e),
//                                                0);
//                                        LOGGER.error("Error closing inputReader", e);
//                                    }
//                                    
//                                    
//                                    // BUFFER CALCULATION
//                                    
//                                    // If almost an arc is present
//                                    int arcSize = arcList.size();
//                                    
//                                    if(arcSize > 0) {                                     
//                                                                                
//                                        String id = null;
//                                        
//                                        // Iteration on all the buffers
//                                        for (Double processedDistance : allDistances) {                                            
//
//                                            // Check if the distance is related to the selected target
//                                            if (!targetManager
//                                                    .isDistanceRelatedToTarget(processedDistance)) {
//                                                continue;
//                                            }                                                                                    
//                                            // Statistical computation
//                                            vse.computeStats(arcList, targetImg, statsMap, false, info);                                                                                                    
//                                            // Iteration on all the geometries list
//                                            for(int i = 0; i < arcSize; i++){
//                                                // Update of the Loop Counter
//                                                loopCounter++;
//                                                // When a certain number of geometries are calculated, a report is printed
//                                                if (loopCounter % reportingLoopStep == 0) {
//                                                    LOGGER.info("computed arcs FROM -" + (loopCounter - 100)
//                                                            + "- TO -" + loopCounter + "-");
//                                                }
//                                                // Selection of the arc
//                                                SimpleFeature arc = arcList.get(i);
//                                                // Selection of the arcId
//                                                String arcId = arcIds.get(i);
//                                                
//                                                // Creation of the identifier associated with the distance
//                                                id = buildFid(arcId, processedDistance);
//                                                // DEBUG: indication of which arc is calculated
//                                                if (LOGGER.isDebugEnabled()) {
//                                                    LOGGER.debug("Computing arc " + arc.getID());
//                                                }
//                                                
//                                                try {
//                                                    // Writing of the result for the selected distance and Id
//                                                    concreteOperation.writeOutputObjects(trace,
//                                                            vulnerabilityObj, total, outFeatureName,
//                                                            arc, id, statsMap.getStatsMap(), partner);
//                                                } catch (Exception e) {
//                                                    errors++;
//                                                    metadataHandler.logError(trace, errors,
//                                                            "Error writing objects on " + geoName, getError(e),
//                                                            0);
//                                                    LOGGER.error("Error writing objects on " + geoName, e);
//                                                }
//                                            }     
//                                        }
//                                        // At the end of the operation on this list
//                                        // all the geometries are cleared for the next 
//                                        // cell.
//                                        arcList.clear();
//                                        arcIds.clear();                                        
//                                    }
//                                    // Update on the Y position
//                                    minY += increment;
//                                    maxY += increment;
//                                }
//                                // Restart the computation on the Y position
//                                maxY = startY + increment - 1;
//                                minY = startY;
//                                // Update on the X position
//                                minX += increment;
//                                maxX += increment;
//                            }
//                            
//                        } else {
//                            // Setting of the input filter
//                            setInputFilter(concreteOperation
//                                    .buildOriginFilter(partner, total, null));
//
//                            while ((inputFeature = readInput()) != null) {
//
//                                // For level 3, get all the arcs that intersect with the current grid cell
//                                FeatureIterator<SimpleFeature> iterator = null;
//                                try {
//                                    // Cell element
//                                    Geometry cell = (Geometry) inputFeature.getDefaultGeometry();
//                                    String linearGeoName = geoName.replace("pl", "ln");
//                                    FeatureSource<SimpleFeatureType, SimpleFeature> reader = createInputReader(
//                                            dataStore, null, linearGeoName);
//                                    // Iterator for selecting all the geometries intersecting the cell
//                                    iterator = reader.getFeatures(
//                                            filterFactory.and(filterFactory.intersects(
//                                                    filterFactory.property(getInputGeometryName(
//                                                            dataStore, linearGeoName)),
//                                                    filterFactory.literal(cell)), partnerFilter))
//                                            .features();
//                                    while (iterator.hasNext()) {
//                                        SimpleFeature sf = (SimpleFeature) iterator.next();
//                                        // Selection of the id associated to the feature.
//                                        BigDecimal arcId = ((BigDecimal) sf.getAttribute(ID_GEO_ARCO));
//                                        // Check if the feature has been already taken
//                                        boolean notContained = keySet.add(arcId);
//                                        if (notContained) {
//                                            arcList.add(sf);
//                                        }
//                                    }
//                                } catch (Exception e) {
//                                    LOGGER.error("Error reading " + geoName, e);
//                                    errors++;
//                                    metadataHandler.logError(trace, errors, "Error reading "
//                                            + geoName, getError(e), 0);
//                                } finally {
//                                    if (iterator != null) {
//                                        iterator.close();
//                                    }
//                                }
//                                // BUFFER CALCULATION
//                                // Selection of the arc id
//                                idArco = ((BigDecimal) inputFeature.getAttribute(ID_GEO_ARCO)).toString();
//                                // If almost an arc is present
//                                if(arcList.size() > 0) {                                     
//                                    // computeBuffersOnArcs                        
//                                    MultipleBufferMap mbm = vse.computeBuffersOnArcs(arcList, allDistances);
//                                    
//                                    String id = null;
//                                    
//                                    // Iteration on all the buffers
//                                    for (Double processedDistance : allDistances) {
//                                        currentDistance = processedDistance;
//                                        // Check if the distance is related to the selected target
//                                        if (!targetManager
//                                                .isDistanceRelatedToTarget(processedDistance)) {
//                                            continue;
//                                        }                                        
//                                        // Creation of the identifier associated with the distance
//                                      id = buildFid(idArco, processedDistance);
//                                      // Statistical computation
//                                      vse.computeStats(mbm.getBuffersForDistance(processedDistance), targetImg, statsMap, false, info);                                                                               
//                                    
//                                      try {
//                                          // Writing of the result for the selected distance and Id
//                                          concreteOperation.writeOutputObjects(trace,
//                                                  vulnerabilityObj, total, outFeatureName,
//                                                  inputFeature, id, statsMap.getStatsMap(), partner);
//                                      } catch (Exception e) {
//                                          errors++;
//                                          metadataHandler.logError(trace, errors,
//                                                  "Error writing objects on " + geoName, getError(e),
//                                                  0);
//                                          LOGGER.error("Error writing objects on " + geoName, e);
//                                      }                                    
//                                    }
//                                    // At the end of the operation on this list
//                                    // all the geometries are cleared for the next 
//                                    // cell
//                                    arcList.clear();
//                                }
//                                // Update of the LoopCounter
//                                loopCounter++;
//                                // When a certain number of geometries are calculated, a report is printed
//                                if (loopCounter % reportingLoopStep == 0) {
//                                    LOGGER.info("computed arcs FROM -" + (loopCounter - 100)
//                                            + "- TO -" + loopCounter + "-");
//                                }
//                                // DEBUG: indication of which arc is calculated
//                                if (LOGGER.isDebugEnabled() && inputFeature != null) {
//                                    LOGGER.debug("Computing arc " + inputFeature.getID());
//                                }                                
//                            } 
//                        }
//                    } catch (Exception e) {
//                        errors++;
//                        metadataHandler.logError(trace, errors,
//                                "Error occurred on raster: " + targetID + " for distance "
//                                        + currentDistance + " on arc:" + idArco,
//                                getError(e), 0);
//                        LOGGER.error("Error occurred on raster: " + targetID
//                                + " for distance " + currentDistance + " on arc:" + idArco
//                                + "\n" + e.getMessage(), e);
//                    }finally{
//                        try{
//                            closeInputReader();
//                        }catch(Exception e){
//                            errors++;
//                            metadataHandler.logError(trace, errors,
//                                    "Error closing inputReader", getError(e),
//                                    0);
//                            LOGGER.error("Error closing inputReader", e);
//                        }
//                        
//                    }                    
//                }               
//                
//                while ((inputFeature = readInput()) != null) {
//
//                    //retrieve the arcs that must be used for the buffer calculation
//                    // TODO move this code outside this class, no if between aggregation level must be there
//                    //          ISSUE: method createInputReader is declared protected in the superclass
//                    try{
//                        List<SimpleFeature> arcList = new ArrayList<SimpleFeature>();
//                        if(aggregationLevel != 3){
//                            // for levels 1 and 2 the inputfeature is already the arc to compute the buffer
//                            arcList.add(inputFeature);
//                        }
//                        else{
//                            // otherwise, for level 3, get all the arcs that intersect with the current grid cell
//                            FeatureIterator<SimpleFeature> iterator = null;
//                            try{
//                                Geometry cell = (Geometry) inputFeature.getDefaultGeometry();
//                                String linearGeoName = geoName.replace("pl", "ln");
//								FeatureSource<SimpleFeatureType, SimpleFeature> reader = createInputReader(
//										dataStore, null,
//										linearGeoName);
//								
//                                iterator = reader.getFeatures(filterFactory.and(
//                                        filterFactory.intersects(filterFactory.property(getInputGeometryName(dataStore, linearGeoName)),
//                                                filterFactory.literal(cell)),
//                                                partnerFilter
//                                                )).features();
//                                while(iterator.hasNext()){
//                                    SimpleFeature sf = (SimpleFeature)iterator.next();
//                                    arcList.add(sf);
//                                }
//                            } catch(Exception e) {
//                            	LOGGER.error("Error reading " + geoName, e);
//                            	errors++;
//                            	metadataHandler
//            						.logError(trace, errors, "Error reading " + geoName, getError(e), 0);
//                            } finally{
//                                if(iterator != null){
//                                    iterator.close();
//                                }
//                            }
//                        }
//                        idArco = ((BigDecimal) inputFeature.getAttribute(ID_GEO_ARCO)).toString();
//                        if(arcList.size() > 0) {
//	                        
//	                        // /// computeBuffersOnArcs                        
//	                        MultipleBufferMap mbm = vse.computeBuffersOnArcs(arcList, allDistances);
//	                        
//	                        // ////
//	
//	                        String id = null;
//	                        
//	                        for (Double processedDistance : allDistances) {
//	                            currentDistance = processedDistance;
//	                            Iterator rasterIter = targetInfo.keySet().iterator();
//	                            while (rasterIter.hasNext()) {
//	
//	                                // save the ID of this target
//	                                targetID = (String) rasterIter.next();
//	
//	                                // Load the target manager, init its status and check if the actual distance is a valid distance for it
//	                                TargetInfo info = targetInfo.get(targetID);
//	                                TargetManager targetManager = info.getManager();
//	                                
//	                                if (!targetManager.isDistanceRelatedToTarget(processedDistance)) {
//	                                    continue;
//	                                }
//	                                
//	                                // Use the cell for crop the raster if the aggregation level == 3, use the buffer otherwise
//	                                Geometry cropArea = (Geometry) (aggregationLevel == 3 ? inputFeature
//	                                        .getDefaultGeometry() : mbm.getBuffersForDistance(
//	                                        processedDistance).get(0));
//	                                
//	                                
//	
//	                                // retrieve the fid for this record
//	                                id = buildFid(idArco, processedDistance);
//	
//	                                ///////// crop images
//	                                // Retrieve the buffer of the arc in the raster space and crop the raster of the target in the raster of the buffer BBOX to run the stats on a smaller raster
//	                                Geometry rasterSpaceGeometry = vse.getRasterGeometry(targetID, cropArea);
//	                                RenderedImage croppedImage = null;
//	                                try {
//	                                	croppedImage = vse.cropImage(targetID, rasterSpaceGeometry);
//	                                } catch(Exception e) {
//	                                	
//	                                }
//	                                ////////
//	
//	                                ///////// Validate crop images
//	                                // Check if the crop operation was succesful
//	                                boolean forceToZero = false;
//	                                if(croppedImage == null){
//	                                    if(LOGGER.isDebugEnabled()){
//	                                        LOGGER.debug("arc: " + inputFeature.getID() + " - target: " + targetID + " set to 0 (bboxes doesn't intersect between them)");
//	                                    }
//	                                    forceToZero = true;
//	                                    continue;
//	                                }
//	                                /////////////
//	                                
//	                                ///////// computeStats
//	                                // Compute the stats on the target 
//	                                try {
//		                                if(aggregationLevel != 3){
//		                                    vse.computeStats(rasterSpaceGeometry, croppedImage, statsMap, forceToZero, info);
//		                                } else {
//		                                    vse.computeStats(mbm.getBuffersForDistance(processedDistance), croppedImage, statsMap, forceToZero, info);
//		                                }
//	                                } catch(Exception e) {
//	                                	errors++;
//	                                	metadataHandler
//	                						.logError(trace, errors, "Error computing ZonalStats on " + geoName, getError(e), 0);
//	                                	LOGGER.error("Error computing ZonalStats on " + geoName, e);
//	                                }
//	                                
//	                                
//	                            }
//	                            try {
//	                            	concreteOperation.writeOutputObjects(trace, vulnerabilityObj, total, outFeatureName, inputFeature, id, statsMap.getStatsMap(), partner);
//	                            } catch(Exception e) {
//                                	errors++;
//                                	metadataHandler
//                						.logError(trace, errors, "Error writing objects on " + geoName, getError(e), 0);
//                                	LOGGER.error("Error writing objects on " + geoName, e);
//                                }
//	                            if(!statsMap.isEmpty()) {
//	                            	statsMap.clear();
//	                            }
//	                            
//	                        }
//	                        
//	                        
//	                        
//	                    }
//                    }
//                    catch(Exception e){
//                    	errors++;
//                    	metadataHandler
//    						.logError(trace, errors, "Error occurred on raster: " + targetID +" for distance " + currentDistance + " on arc:" + idArco, getError(e), 0);                        
//                        LOGGER.error("Error occurred on raster: " + targetID +" for distance " + currentDistance + " on arc:" + idArco +  "\n" + e.getMessage(), e);
//                    }
//
//                    loopCounter++;
//
//                    //int id = nextId(startId);
//                    if(loopCounter % reportingLoopStep == 0){
//                        LOGGER.info("computed arcs FROM -" + (loopCounter-100) + "- TO -" + loopCounter + "-");
//                    }
//                    if(LOGGER.isDebugEnabled() && inputFeature != null){
//                        LOGGER.debug("Computing arc " + inputFeature.getID());
//                    }
//                }
                
                // Report about the end of the input
                importFinished(total, errors - startErrors, "Data imported in " + outFeatureName);
            } finally {
                closeInputReader();
                LOGGER.info("Write errors: " + errors + " - other errors: " + otherErrors);
                
                if (process != -1 && closePhase != null) {
					// close current process phase
					metadataHandler.closeProcessPhase(process, closePhase);
				}
                transaction.close();
            }
        }
    }

    private static String buildFid(String idArco, Double el){
        return idArco + "." +el.intValue();
    }
}
