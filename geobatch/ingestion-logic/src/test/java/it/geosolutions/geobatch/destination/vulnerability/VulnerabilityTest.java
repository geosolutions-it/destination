/*
 *  Copyright (C) 2007-2012 GeoSolutions S.A.S.
 *  http://www.geo-solutions.it
 *
 *  GPLv3 + Classpath exception
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.geosolutions.geobatch.destination.vulnerability;

import it.geosolutions.destination.utils.BufferUtils;
import it.geosolutions.geobatch.destination.commons.DestinationOnlineTestCase;
import it.geosolutions.geobatch.destination.ingestion.MetadataIngestionHandler;
import it.geosolutions.geobatch.flow.event.ProgressListenerForwarder;

import java.awt.RenderingHints;
import java.awt.image.RenderedImage;
import java.io.File;
import java.io.IOException;
import java.io.Serializable;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import javax.imageio.ImageIO;
import javax.imageio.stream.ImageInputStream;
import javax.media.jai.JAI;
import javax.media.jai.ParameterBlockJAI;
import javax.media.jai.PlanarImage;
import javax.media.jai.ROI;
import javax.media.jai.RenderedOp;
import javax.media.jai.operator.MosaicDescriptor;

import org.geotools.data.DataStoreFinder;
import org.geotools.data.simple.SimpleFeatureCollection;
import org.geotools.data.simple.SimpleFeatureIterator;
import org.geotools.feature.DefaultFeatureCollection;
import org.geotools.feature.simple.SimpleFeatureBuilder;
import org.geotools.feature.simple.SimpleFeatureTypeBuilder;
import org.geotools.gce.geotiff.GeoTiffReader;
import org.geotools.geometry.jts.JTS;
import org.geotools.jdbc.JDBCDataStore;
import org.geotools.referencing.CRS;
import org.jaitools.imageutils.ROIGeometry;
import org.jaitools.media.jai.zonalstats.Result;
import org.jaitools.media.jai.zonalstats.ZonalStats;
import org.jaitools.media.jai.zonalstats.ZonalStatsDescriptor;
import org.jaitools.numeric.Statistic;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.geometry.MismatchedDimensionException;
import org.opengis.referencing.datum.PixelInCell;
import org.opengis.referencing.operation.MathTransform;
import org.opengis.referencing.operation.TransformException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.sun.media.jai.operator.ImageReadDescriptor;
import com.vividsolutions.jts.geom.Coordinate;
import com.vividsolutions.jts.geom.Geometry;
import com.vividsolutions.jts.geom.GeometryFactory;
import com.vividsolutions.jts.geom.LinearRing;
import com.vividsolutions.jts.geom.Polygon;
import com.vividsolutions.jts.io.ParseException;
import com.vividsolutions.jts.io.WKTReader;

/**
 * @author DamianoG
 *
 */
public class VulnerabilityTest extends DestinationOnlineTestCase{

    private final static Logger LOGGER = LoggerFactory.getLogger(VulnerabilityTest.class);
    
    Integer valuesA[] = {1,2,3,5,6};
    
    @Before
    public void before() throws Exception{
        setOriginTable("siig_geo_ln_arco_1");
        super.before();
    }
    
    @Ignore
    @Test
    public void testHumanTarget() throws Exception{
        LOGGER.info("Human target Test...");
        TargetPropertiesLoader propertiesLoader = new TargetPropertiesLoader(); 
        Properties targetMapping = propertiesLoader.getTargetMapping();
        String imgUrl = getRasterParams("human_target");
        List<Integer> values = Arrays.asList(valuesA);
        List<Result> results = computeSimplyfiedVulnerabilityProcess("", imgUrl, null);
        TargetManager trg = TargetManager.createManager(TargetPropertiesLoader.UMANI_PREFIX.toString(), TargetType.COMPUTEPIXEL, null, 100);
        ResultStatsMap rsm = new ResultStatsMap(null);
        trg.handleResults(results, rsm, false);
    }
    
    @Ignore
    @Test
    public void testNotHumanTarget() throws Exception{
        LOGGER.info("NotHuman target Test...");
        TargetPropertiesLoader propertiesLoader = new TargetPropertiesLoader(); 
        Properties targetMapping = propertiesLoader.getTargetMapping();
        String imgUrl = getRasterParams("not_human_target"); 
        List<Integer> values = Arrays.asList(valuesA);
        List<Result> results = computeSimplyfiedVulnerabilityProcess("", imgUrl, null);
        TargetManager trg = TargetManager.createManager(TargetPropertiesLoader.NON_UMANI_PREFIX.toString(), TargetType.COMPUTEAREA, null, 100);
        ResultStatsMap rsm = new ResultStatsMap(null);
        trg.handleResults(results, rsm, false);
    }
    
    @Ignore
    @Test
    public void testGroundCoverage() throws Exception{
        LOGGER.info("GroundCoverage Test...");
        TargetPropertiesLoader propertiesLoader = new TargetPropertiesLoader(); 
        Properties targetMapping = propertiesLoader.getTargetMapping();
        String imgUrl = getRasterParams("ground_coverage_target");
        List<Integer> values = Arrays.asList(valuesA);
        List<Result> results = computeSimplyfiedVulnerabilityProcess("", imgUrl, values);
        TargetManager trg = TargetManager.createManager(TargetPropertiesLoader.COP_SUOLO_PREFIX.toString(), TargetType.GROUPED, null, 100);
        Map<Integer, String> valuesZone = propertiesLoader.getTargetValuesZone();
        trg.handleResults(results, new ResultStatsMap(null), false);
    }
    
    public List<Result> computeSimplyfiedVulnerabilityProcess(String basePath, String imageName, List<Integer> values) throws Exception {  
        String imgAbsolutePath = basePath + imageName; 
        RenderedImage image = loadImage(true, new File(imgAbsolutePath));
        GeoTiffReader gtr = new GeoTiffReader(new File(imgAbsolutePath));
        
        String names[] = {"distance0","distance1","distance2"}; 
        Double distances[] = {8d,250d,750d};
        
        DistancesPair dp = new DistancesPair(names, distances);
        
        // Load the feature from DB uncomment that part (and comment the following) to load the feature from the DB
//        FilterFactory2 ff2 = CommonFactoryFinder.getFilterFactory2();
//        FeatureStore<SimpleFeatureType, SimpleFeature> inputReader = MetadataIngestionHandler.createFeatureSource(dataStore, null, "siig_geo_ln_arco_1");
//        Query q = new Query();
//        q.setFilter(ff2.equals(ff2.property("id_geo_arco"), ff2.literal(170175l)));
//        FeatureIterator<SimpleFeature> inputIterator = inputReader.getFeatures(q).features();
//        SimpleFeature feature = inputIterator.next();
        
        // The feature used is from Piemonte partner and that's is the original configuration imported by shapefile
        // id_geo_arco, nr_incidenti, nr_incidenti_elab, nr_corsie, lunghezza, nr_bers_umani_strada, id_tematico_shape, fk_partner, geometria, id_origine, flg_nr_corsie, flg_nr_incidenti
        // 170175;1;;2;100;;169190;"1";"<see the hardcoded wkt below>";17869;"S";"C"
        // use this query for retrieve it from DB (and maybe use its id in the code snippets above):
        //
        // SELECT * FROM siig_p.siig_geo_ln_arco_1 
        // WHERE ST_asText(geometria) = 'MULTILINESTRING((394470.901 4992155.4087,394528.2185 4992125.5,394559.614 4992109.2571))';
        SimpleFeatureTypeBuilder tb = new SimpleFeatureTypeBuilder();
        tb.setCRS(CRS.decode("EPSG:32632"));
        tb.setName("featureType");
        tb.add("geometria", Geometry.class);
        tb.add("integer", Integer.class);
        SimpleFeatureBuilder b = new SimpleFeatureBuilder(tb.buildFeatureType());
        b.add("MULTILINESTRING((394470.901 4992155.4087,394528.2185 4992125.5,394559.614 4992109.2571))");
        SimpleFeature sf = b.buildFeature("1");
        
        // compute the buffer
        Map<Double, Geometry> buffers = VulnerabilityUtils.computeBuffers(sf, dp);
        // get the geometry in the raster space
        Geometry roiGeom = VulnerabilityUtils.toRasterSpace(buffers.get(750d), gtr.getOriginalGridToWorld(PixelInCell.CELL_CENTER).inverse());
        // retrieve NODATA value for that raster
        Double noData = VulnerabilityUtils.getNoDataValue(gtr);
        // crop the raster of the target using the buffered arc BBox
        RenderedImage croppedImage = VulnerabilityUtils.cropImage(image, roiGeom);
        printCroppedImage(croppedImage, roiGeom);
        // Run sum stats
        // Removed the calculation,.. the test is ignored.....
        //List<Result> results = VulnerabilityUtils.sumCellsInsideBuffer(roiGeom, croppedImage, noData, 0, null);
        // 
        return null;
        
    }
    
        public void printCroppedImage(RenderedImage croppedImage, Geometry roiGeom) throws IOException{
        // save the files (with or without ROI) for a visual feedback
           RenderedImage[] imgArr = new RenderedImage[] { croppedImage };
           
           ROIGeometry roi = new ROIGeometry(roiGeom);
           ROIGeometry[] rgeomArr = new ROIGeometry[] { roi };
           
           RenderedOp ro = MosaicDescriptor.create(imgArr, MosaicDescriptor.MOSAIC_TYPE_OVERLAY, null,rgeomArr, null, new double[] { 0 }, null);
           
           File tmp = new File("C:\\Users\\geosolutions\\Documents\\destination\\targets_raster\\tiled\\test.png");
           //BufferedImage bi = ro.getAsBufferedImage();
           ImageIO.write(/*croppedImage*/ro, "png", tmp);
//           BufferedImage bi = ro.getAsBufferedImage();
   //
//           File tmp2 = TestData.temp(this, "saved2.png");
//           ImageIO.write(bi, "png", tmp2);
       }
    
    @Ignore
    @Test
    public void testBuffer1() throws IOException {

        SimpleFeatureCollection features = createFeature();
        Double[] distances = new Double[] { 1.0 };
        
        String[] distanceNames = new String[] { "distance1", };
        SimpleFeatureCollection outputCollection = BufferUtils.createMultipleBuffer(features, distances,
                distanceNames);

        Geometry the_geom = null;

        SimpleFeatureIterator iter = outputCollection.features();
        while (iter.hasNext()) {
            SimpleFeature feature = iter.next();
            the_geom = (Geometry) feature.getDefaultGeometry();
            System.out.println(the_geom.getArea());
        }
        
        RenderedImage myData = createConstantImage();
        ROI roi = new ROIGeometry(the_geom);

        ParameterBlockJAI pb = new ParameterBlockJAI("ZonalStats");
        pb.setSource("dataImage", myData);
        // pb.setSource("zoneImage", myZones);
        pb.setParameter("roi", roi);

        Statistic[] stats = { Statistic.SUM, };

        pb.setParameter("stats", stats);
        RenderedOp op = JAI.create("ZonalStats", pb);

        ZonalStats res = (ZonalStats) op.getProperty(ZonalStatsDescriptor.ZONAL_STATS_PROPERTY);

        // print results to console
        for (Result r : res.results()) {
            System.out.println(r);
        }
        
    }

    @Test @Ignore
    public void testBuffer2() throws IOException, ParseException, MismatchedDimensionException, TransformException {

        Geometry geom = createGeom();
        RenderedImage myData = loadImage(true, new File(getRasterParams("human_target")));
        
        GeoTiffReader gtr = new GeoTiffReader(new File(getRasterParams("human_target")));
        // get the world to grid matrix
        MathTransform g2w = gtr.getOriginalGridToWorld(PixelInCell.CELL_CORNER); // TODO Corner or Center?
        MathTransform w2g = g2w.inverse();
        Geometry targetGeom = JTS.transform(geom, w2g);
        
        Double[] distances = new Double[] { 200.0, 300.0, 400.0, 500.0 };
        
        String[] distanceNames = new String[] { "distance1", "distance2", "distance3", "distance4" };
        
        
        SimpleFeatureTypeBuilder tb = new SimpleFeatureTypeBuilder();
        tb.setName("featureType");
        tb.add("geometry", Geometry.class);
        tb.add("integer", Integer.class);
        SimpleFeatureBuilder b = new SimpleFeatureBuilder(tb.buildFeatureType());
        DefaultFeatureCollection features = new DefaultFeatureCollection(null, b.getFeatureType());
        b.add(targetGeom);
        b.add(0);
        features.add(b.buildFeature("piemontelinestring"));
        
        SimpleFeatureCollection outputCollection = BufferUtils.createMultipleBuffer(features, distances,
                distanceNames);

        Geometry the_geom = null;
        Geometry the_geom2 = null;
        Geometry the_geom3 = null;
        Geometry the_geom4 = null;

        SimpleFeatureIterator iter = outputCollection.features();
        while (iter.hasNext()) {

            SimpleFeature feature = iter.next();

            the_geom = (Geometry) feature.getDefaultGeometry();
            System.out.println(the_geom.getArea());

            // the_geom1 = (Geometry)feature.getAttribute("geometry1");
            // System.out.println(the_geom1.getArea());

            the_geom2 = (Geometry) feature.getAttribute("geometry2");
            System.out.println(the_geom2.getArea());

            the_geom3 = (Geometry) feature.getAttribute("geometry3");
            System.out.println(the_geom3.getArea());

            the_geom4 = (Geometry) feature.getAttribute("geometry4");
            System.out.println(the_geom4.getArea());

        }

        
        ROI roi = new ROIGeometry(the_geom);

        ParameterBlockJAI pb = new ParameterBlockJAI("ZonalStats");
        pb.setSource("dataImage", myData);
        // pb.setSource("zoneImage", myZones);
        pb.setParameter("roi", roi);

        Statistic[] stats = { Statistic.SUM, };

        pb.setParameter("stats", stats);
        RenderedOp op = JAI.create("ZonalStats", pb);

        ZonalStats res = (ZonalStats) op.getProperty(ZonalStatsDescriptor.ZONAL_STATS_PROPERTY);

        // print results to console
        for (Result r : res.results()) {
            System.out.println(r);
        }
    }

    private static SimpleFeatureCollection createFeature() {

        SimpleFeatureTypeBuilder tb = new SimpleFeatureTypeBuilder();
        tb.setName("featureType");
        tb.add("geometry", Geometry.class);
        tb.add("integer", Integer.class);

        GeometryFactory gf = new GeometryFactory();

        SimpleFeatureBuilder b = new SimpleFeatureBuilder(tb.buildFeatureType());
        DefaultFeatureCollection features = new DefaultFeatureCollection(null, b.getFeatureType());

        Coordinate array[] = new Coordinate[5];
        array[0] = new Coordinate(1, 1);
        array[1] = new Coordinate(1, 2);
        array[2] = new Coordinate(2, 2);
        array[3] = new Coordinate(2, 1);
        array[4] = new Coordinate(1, 1);
        LinearRing lr = gf.createLinearRing(array);
        Polygon p = gf.createPolygon(lr, null);
        b.add(p);
        features.add(b.buildFeature("1"));

        return features;
    }

    private static Geometry createGeom() throws ParseException {

        WKTReader wktReader = new WKTReader();
        Geometry sourceGeom = wktReader.read("LINESTRING(359136 5047674, 380407 5047590, 380995 5036492)");
        
        return sourceGeom;
    }

    /**
     * Loads a {@link RenderedImage} from the specified file with the specified mode.
     * 
     * @param mode, {@link ComputationMode} can be {@link ComputationMode#DEFERRED} or {@link ComputationMode#IMMEDIATE} as per the JAI meaning.
     * @param tiffFile the input {@link File} where to read from.
     * 
     * @return
     * @throws IOException in case the creation of the {@link ImageInputStream} or the Immediate read with Imageio fails.
     */
    private static RenderedImage loadImage(boolean deferred, File tiffFile) throws IOException {
        // checks
        if (!tiffFile.isFile() || !tiffFile.exists() || !tiffFile.canRead()) {
            throw new IllegalArgumentException("Unable to load image from file: "
                    + tiffFile.getAbsolutePath() + "\n" + "isFile=" + tiffFile.isFile() + "\n"
                    + "exists=" + tiffFile.exists() + "\n" + "canRead=" + tiffFile.canRead());
        }

        if (deferred) {
            final ImageInputStream inStream = ImageIO.createImageInputStream(tiffFile);
            if (inStream == null) {
                throw new IllegalArgumentException("Unable to create input stream from file: "
                        + tiffFile.getAbsolutePath() + "\n" + "isFile=" + tiffFile.isFile() + "\n"
                        + "exists=" + tiffFile.exists() + "\n" + "canRead=" + tiffFile.canRead());
            }
            return ImageReadDescriptor.create(inStream, Integer.valueOf(0), false, false, false,
                    null, null, null, null, null);
        } else {
            return ImageIO.read(tiffFile);

        }

    }

    private static PlanarImage createConstantImage() {

        RenderingHints hints = null;

        ParameterBlockJAI pb = new ParameterBlockJAI("constant");
        pb.setParameter("width", 128f);
        pb.setParameter("height", 128f);
        pb.setParameter("bandValues", new Double[] { 1.0 });

        return JAI.create("constant", pb, hints).getRendering();
    }

    @Override
    protected String getFixtureId() {
        return "destination";
    }
    
    @Override
    protected Properties createExampleFixture() {
        Properties ret = new Properties();
        for (Map.Entry entry : getExamplePostgisProps().entrySet()) {
            ret.setProperty(entry.getKey().toString(), entry.getValue().toString());
        }
        return ret;
    }
    
    // *******************************************************************
    // Utility methods for run the Vulnerability Process outside GeoBatch
    // *******************************************************************
    
    @Test  @Ignore
    public void testVulnerabilityProcess(){
        computeVulnerability();
    }
    
    public static void main(String [] args){
        //computeVulnerability();
        VulnerabilityTest vtest = new VulnerabilityTest();
        
        VulnThread vt1 = vtest.new VulnThread(null, null);
        Thread t1 = new Thread(vt1);
        t1.start();
        
//        VulnThread vt1 = vtest.new VulnThread(1l, 50000l);
//        Thread t1 = new Thread(vt1);
//        t1.start();
        
//        VulnThread vt2 = vtest.new VulnThread(50001l, 100000l);
//        Thread t2 = new Thread(vt2);
//        t2.start();
//        
//        VulnThread vt3 = vtest.new VulnThread(100001l, 150000l);
//        Thread t3 = new Thread(vt3);
//        t3.start();
//        
//        VulnThread vt4 = vtest.new VulnThread(150000l, 207363l);
//        Thread t4 = new Thread(vt4);
//        t4.start();
    }
    
    public static void computeVulnerability(){
        computeVulnerability(null, null);
    }
    
    public static void computeVulnerability(Long start, Long end){
        Map<String, Serializable> datastoreParams = new HashMap<String, Serializable>();
        datastoreParams.put("port", 5432);
        datastoreParams.put("schema", "siig_p");
        datastoreParams.put("passwd", "siig_p");
        datastoreParams.put("dbtype", "postgis");
        datastoreParams.put("host", "192.168.88.132");
        datastoreParams.put("Expose primary keys", "true");
        datastoreParams.put("user", "siig_p");
        datastoreParams.put("database", "destination_staging");
        JDBCDataStore dataStore = null;        
        MetadataIngestionHandler metadataHandler = null;
        try {
        	
        	dataStore = (JDBCDataStore)DataStoreFinder.getDataStore(datastoreParams);	        
	        metadataHandler = new MetadataIngestionHandler(dataStore);
			VulnerabilityComputation vulnerabilityComputation = new VulnerabilityComputation(
					"siig_geo_ln_arco_3", new ProgressListenerForwarder(null),
					metadataHandler, dataStore);
       
            vulnerabilityComputation.setStartOriginId(start);
            vulnerabilityComputation.setEndOriginId(end);
            vulnerabilityComputation.computeVulnerability(null, 1, "PURGE_INSERT", null, null, null, null, null, 0, 0, 0, 0, false, null, null, null, null, null, null);
        } catch (IOException e) {
        } finally {
        	if(metadataHandler != null) {
        		metadataHandler.dispose();
        	}
        	
        	if(dataStore != null) {
        		dataStore.dispose();
        	}        	
        }
    }
    
    private class VulnThread implements Runnable{

        private Long start;
        private Long end;
        
        public VulnThread(Long start, Long end){
            this.start = start;
            this.end = end;
        }
        
        @Override
        public void run() {
            computeVulnerability(start, end);
        }
        
    }

}
