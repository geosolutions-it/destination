/*
 *  Copyright (C) 2007-2012 GeoSolutions S.A.S.
 *  http://www.geo-solutions.it
 *
 *  GPLv3 + Classpath exception
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.geosolutions.geobatch.destination.vulnerability;

import java.awt.image.RenderedImage;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import org.geotools.gce.geotiff.GeoTiffReader;
import org.jaitools.media.jai.zonalstats.Result;
import org.opengis.feature.simple.SimpleFeature;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vividsolutions.jts.geom.Geometry;

/**
 * @author DamianoG
 *
 */
public class VulnerabilityStatsEngine {

    private final static Logger LOGGER = LoggerFactory.getLogger(VulnerabilityStatsEngine.class);
    
    private static TargetPropertiesLoader propertiesLoader;
    private static Properties targetURIs;
    private static Map<String,GeoTiffReader> targetReaders;
    private static Map<String,RenderedImage> targetRasters;
    
    static{
        try {
            propertiesLoader = new TargetPropertiesLoader();
            targetURIs = propertiesLoader.getTargetURIs();
            targetReaders = VulnerabilityUtils.loadGTIFFReaders(targetURIs);
            targetRasters = VulnerabilityUtils.loadImages(targetURIs);
        } catch (IOException e) {
            LOGGER.error(e.getMessage(), e);
        }
    }
    
    public VulnerabilityStatsEngine(){}
    
    public MultipleBufferMap computeBuffersOnArcs(List<SimpleFeature> inputFeatures, List<Double> allDistances){
        MultipleBufferMap mbm = new MultipleBufferMap();
        for(SimpleFeature feat : inputFeatures){
            DistancesPair allDistancesForComputation =  TargetPropertiesLoader.createPairDistance(allDistances);
            Map<Double, Geometry> buffersMap = VulnerabilityUtils.computeBuffers(feat, allDistancesForComputation);
            mbm.addMap(buffersMap);
        }
        return mbm;
    }
    
    /**
     * Retrieve the buffer of the arc in the raster space 
     * and crop the raster of the target in the raster of the buffer BBOX to run the stats on a smaller raster
     * 
     * @param targetID
     * @param buffers
     * @return
     * @throws Exception 
     */
    public RenderedImage cropImage(String targetID, Geometry cropArea) throws Exception{
        RenderedImage image = targetRasters.get(targetID);
        Geometry roiGeom = VulnerabilityUtils.toRasterSpace(cropArea, targetReaders.get(targetID));
        RenderedImage croppedImage = VulnerabilityUtils.cropImage(image, roiGeom);
        return croppedImage;
    }
    
    /**
     * Retrieve the NoData value for the raster related to a target
     * 
     * @param targetID
     * @return
     */
    public Double getNoData(String targetID){
        return VulnerabilityUtils.getNoDataValue(targetReaders.get(targetID));
    }
    
    /**
     * Check if a previous crop operation was succesful on all rasters
     * 
     * @param croppedImages
     * @return
     */
    public boolean validateCroppedImages(List<RenderedImage> croppedImages){
        for(RenderedImage croppedImage : croppedImages){
            if(croppedImage == null){
                return false;
            }
        }
        return true;
    }
    
    /**
     * 
     * Compute the stats and create the statsMap
     * 
     * @param roiGeom
     * @param image
     * @param noData
     * @param resMap
     * @param forceToZero
     * @param targetManager
     * @param valuesToCount
     * @throws Exception 
     */
    public void computeStats(List<Geometry> roiGeom, RenderedImage croppedImage, Double noData, ResultStatsMap resMap, boolean forceToZero, TargetManager targetManager, String targetID) throws Exception{
        for(Geometry roi : roiGeom){
            Geometry rasterRoi = VulnerabilityUtils.toRasterSpace(roi, targetReaders.get(targetID));
            List<Result> results = VulnerabilityUtils.sumCellsInsideBuffer(rasterRoi, croppedImage, noData, 0, targetManager.getPixelValues());
            ResultStatsMap otherMap = resMap.clone();
            targetManager.handleResults(results, otherMap, forceToZero);
            resMap.sum(otherMap);
        }
    }
}
