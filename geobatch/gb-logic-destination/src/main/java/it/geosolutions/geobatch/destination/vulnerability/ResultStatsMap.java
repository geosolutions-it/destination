/*
 *  Copyright (C) 2007-2012 GeoSolutions S.A.S.
 *  http://www.geo-solutions.it
 *
 *  GPLv3 + Classpath exception
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.geosolutions.geobatch.destination.vulnerability;

import static it.geosolutions.geobatch.destination.vulnerability.TargetPropertiesLoader.COP_SUOLO_PREFIX;
import static it.geosolutions.geobatch.destination.vulnerability.TargetPropertiesLoader.PROP_NAMESPACE_SEPARATOR;

import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

import org.apache.commons.collections.MapUtils;
import org.apache.commons.collections.SetUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * @author DamianoG
 *
 * This class store the vulnerability value for a given arc and distance.
 * For each target the result can be stored usining simply the targetId, internally the targetID will be converted into the related field name of the Vulnerability Table.   
 */
public class ResultStatsMap {
    
    private final static Logger LOGGER = LoggerFactory.getLogger(ResultStatsMap.class);
    
    /**
     * The map where the result will be stored
     */
    private Map<String, Double> statsMap;
    
    /**
     * The map that associate the pixelValue to the related zone of GroundCoverageTarget
     */
    private Map<Integer, String> valuesZone;
    
    /**
     * The association between target IDs and vulnerability field table
     */
    private Properties targetMapping;
    
    public ResultStatsMap(Properties targetMapping, Map<Integer, String> valuesZone){
        this.statsMap = new HashMap<String, Double>();
        this.targetMapping = targetMapping;
        this.valuesZone = valuesZone;
    }
    
    /**
     * Add a result to the statsMap, the targetID will be converted into the field name in the Vulnerability Table.
     * 
     * @param targetID
     * @param value
     * @param forceToZero
     */
    public void addResult(String targetID, Double value, boolean forceToZero){
        if(forceToZero){
            statsMap.put(targetMapping.getProperty(targetID), 0d);
        }
        else{
            statsMap.put(targetMapping.getProperty(targetID), value);
        }
    }
    
    /**
     * 
     * Add a result to the statsMap using the pixel value instead of TargetID.
     * The pixelValue will be converted into the targetID than it will be converted into the field name in the Vulnerability Table.
     * 
     * @param pixelValue
     * @param value
     * @param forceToZero
     */
    public void addResultFromPixelValue(Integer pixelValue, Double value, boolean forceToZero){
        addResult(fromPixelValueToTargetId(pixelValue), value, forceToZero);
    }
    
    /**
     * Sum the values of otherMap into this map 
     * For ensure the correctnes of the operation use a map generated with clone method
     * 
     * @param otherMap
     */
    public void sum(ResultStatsMap otherMap){
        for(String key : otherMap.getKeySet()){
            Double statValue = (Double) otherMap.getStatsMap().get(key);
            Double d = (Double)statsMap.get(key);
            statValue += d != null ? d : 0;
            statsMap.put(key, statValue);
        }
    }
    
    /**
     * Create a new empty map with the same valuesZone and targetMapping
     */
    public ResultStatsMap clone(){
        ResultStatsMap rsm = new ResultStatsMap(targetMapping, valuesZone);
        return rsm;
    }
    
    public void clear(){
        statsMap.clear();
    }
    
    public boolean isEmpty(){
        return statsMap.isEmpty();
    }
    
    public Map getStatsMap(){
        return MapUtils.unmodifiableMap(statsMap);
    }
    
    public Set<String> getKeySet(){
        return SetUtils.unmodifiableSet(statsMap.keySet());
    }
    
    private String fromPixelValueToTargetId(Integer pixelValue){
        return COP_SUOLO_PREFIX+PROP_NAMESPACE_SEPARATOR+valuesZone.get(pixelValue.intValue());
    }
}
