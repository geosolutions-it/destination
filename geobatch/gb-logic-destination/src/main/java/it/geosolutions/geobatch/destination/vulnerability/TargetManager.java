/*
 *  Copyright (C) 2007-2012 GeoSolutions S.A.S.
 *  http://www.geo-solutions.it
 *
 *  GPLv3 + Classpath exception
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.geosolutions.geobatch.destination.vulnerability;

import static it.geosolutions.geobatch.destination.vulnerability.TargetPropertiesLoader.UMANI_PREFIX;

import java.awt.image.RenderedImage;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.apache.commons.collections.ListUtils;
import org.jaitools.media.jai.zonalstats.Result;
import org.jaitools.numeric.Range;
import org.opengis.referencing.operation.MathTransform;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This class is responsible for managing the different types of Target (Human - NotHuman - GroundCoverage )
 * providing a single API.
 * The abstraction is implemented by the 3 inner class that are instantiated with the getInstance method.  
 * 
 * @author DamianoG
 * 
 */
public abstract class TargetManager {

    public static class TargetInfo {
        public TargetInfo(String id, MathTransform world2Grid, Double nodata, RenderedImage raster, int pixelArea) {
            this.world2Grid = world2Grid;
            this.nodata = nodata;
            this.raster = raster;
            this.id = id;
            manager = TargetManager.createManager(id, pixelArea);
        }

        public MathTransform getWorld2Grid() {
            return world2Grid;
        }

        public Double getNodata() {
            return nodata;
        }

        public RenderedImage getRaster() {
            return raster;
        }

        public TargetManager getManager() {
            return manager;
        }

        public String getId() {
            return id;
        }

        MathTransform world2Grid;

        Double nodata;

        RenderedImage raster;

        String id;

        TargetManager manager;
    }
    
    private final static Logger LOGGER = LoggerFactory.getLogger(TargetManager.class);
    
    protected static Map<String, Double[]> allDistances;
    protected static List<Integer> copSuoloValues;
    
    static{
        allDistances = TargetPropertiesLoader.loadDistances();
        TargetPropertiesLoader tpl = new TargetPropertiesLoader();
        copSuoloValues = tpl.getAllCopSuoloValues();
    }
    
    /**
     * The resolutions of the pixels
     */
    protected int pixelArea;
    
    /**
     * The accepted distances for this Target. The initTargets() method is responsible for init it.
     */
    protected Double [] distances;
    
    /**
     * The id of the target as specified in the properties file
     */
    protected String targetID;
    
    /**
     * The value of copSuolo pixels. This is initialized (with the static list) just if the concrete class is of type GroundCoverage.
     * Otherwise it must be null.
     */
    protected List<Integer> pixelValues;
    
    public TargetManager(String targetID, int pixelArea){
        this.targetID = targetID;
        this.pixelArea = pixelArea <= 0 ? 100 : pixelArea;
        initTarget();
    }
    
    /**
     * Basically load the distances for the target and the range values (if the target is type of GroundCoverageTarget)
     * any other further initialization stuff could be implemented here.
     */
    public abstract void initTarget();
    
    /**
     * Handle the results and add them to the resultStatsMap provided as input
     * 
     * @param results
     * @param statsMap
     */
    public abstract void handleResults(List<Result> results, ResultStatsMap statsMap, boolean forceToZero);
    
    /**
     * Check if the provided input distance is accepted by this target
     * 
     * @param distance
     * @return
     */
    public boolean isDistanceRelatedToTarget(Double distance){
        return Arrays.asList(distances).contains(distance);
    }

    public List<Integer> getPixelValues(){
        if(pixelValues == null){
            return null;
        }
        return ListUtils.unmodifiableList(pixelValues);
    }

    public List<Double> getDistances(){
        if (distances == null){
            return null;
        }
        return ListUtils.unmodifiableList(Arrays.asList(distances));
    }
    
    //**************************************
    //  Concrete Targets Implementation
    //**************************************
    
    
    /**
     * In The rasters of Human Targets each pixel contains the number of the humans present in that area.
     * So basically we have to take the result of the stat SUM and store it in the result Map   
     * 
     * @author DamianoG
     *
     */
    private static class HumanTarget extends TargetManager{

        /**
         * @param pixelArea
         */
        public HumanTarget(String targetID, int pixelArea) {
            super(targetID, pixelArea);
        }

        @Override
        public void initTarget() {
            distances = allDistances.get(UMANI_PREFIX);
        }

        @Override
        public void handleResults(List<Result> results, ResultStatsMap statsMap, boolean forceToZero) {
            for(Result el3 : results){
                Double resSimple = (el3.getValue().equals(Double.NaN)?0d:el3.getValue());
                //Long countSimple = el3.getNumOffered();
                statsMap.addResult(targetID, resSimple, forceToZero);                                
            }
        }
    }
    
    /**
     * In The rasters of NotHuman Targets each pixel that is different to NODATA represent a snippet of the area of that target
     * We want calculate the mq2 present inside a given ROI so we have to count the pixel used for calculate the stat sum and multiply that value for the resolution of the pixel
     * So basically we have to take the result of the stat SUM and store it in the result Map
     * 
     * @author DamianoG
     *
     */
    private static class NotHumanTarget extends TargetManager{

        /**
         * @param pixelArea
         */
        public NotHumanTarget(String targetID, int pixelArea) {
            super(targetID, pixelArea);
        }

        @Override
        public void initTarget() {
            distances = allDistances.get(targetID);
        }

        @Override
        public void handleResults(List<Result> results, ResultStatsMap statsMap, boolean forceToZero) {
            for(Result el3 : results){
                //Double resSimple = (el3.getValue().equals(Double.NaN)?0d:el3.getValue());
                // TODO check if must be used numOffered or numAccepted for retrieve the number of valid (without NODATA) pixels used for the stats
                Long countSimple = el3.getNumOffered();
                statsMap.addResult(targetID, Double.valueOf(countSimple)*pixelArea, forceToZero);                                
            }
        }
    }
    
    /**
     * The GroundCoverageTarget is a special case of NotHumanTarget.
     * Basically in a single raster is stored more than one NotHuman target.
     * Depending on the value of the pixel it could refers to a target or another.
     * So before count the pixel we have to clusterize the results by the different pixel values 
     * 
     * @author DamianoG
     *
     */
    private static class GroundCoverageTarget extends TargetManager{

        /**
         * @param pixelArea
         */
        public GroundCoverageTarget(String targetID, int pixelArea) {
            super(targetID, pixelArea);
        }

        @Override
        public void initTarget() {
            distances = allDistances.get(targetID);
            pixelValues = TargetManager.copSuoloValues;
        }

        @Override
        public void handleResults(List<Result> results, ResultStatsMap statsMap, boolean forceToZero) {
            for(Result el3 : results){
                Double resSimple = (el3.getValue().equals(Double.NaN)?0d:el3.getValue());
                //Long countSimple = el3.getNumOffered();
                Iterator rangeIter = el3.getRanges().iterator();
                while(rangeIter.hasNext()){
                    Range range = (Range)rangeIter.next();
                    Number value = range.getMax();
                    if(resSimple != 0 && resSimple != Double.NaN){
                        statsMap.addResultFromPixelValue(value.intValue(), Double.valueOf(resSimple/value.doubleValue())*pixelArea, forceToZero);
                    }
                    else{
                        statsMap.addResultFromPixelValue(value.intValue(), 0d, true);
                    }
                }
                
            }   
        }
    }
    
    /**
     * This method instantiate a concrete implementation of TargetManager parsing 
     * the provided Target name and init the targetID.
     * 
     * @param targetName
     * @param pixelArea if < 0 the default value is 100
     * 
     * @return a concrete implementation of TargetManager
     */
    public static TargetManager createManager(String targetName, int pixelArea) {
        if (targetName == null) {
            throw new IllegalArgumentException("targetName is null...");
        }
        TargetManager manager = null;

        if (targetName.startsWith(TargetPropertiesLoader.UMANI_PREFIX)) {
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("HumanTarget Instantiated...");
            }
            manager = new HumanTarget(targetName, pixelArea);
        } else if (targetName.startsWith(TargetPropertiesLoader.COP_SUOLO_PREFIX)) {
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("GroundCoverage Instantiated...");
            }
            manager = new GroundCoverageTarget(targetName, pixelArea);
        } else if (targetName.startsWith(TargetPropertiesLoader.NON_UMANI_PREFIX)) {
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("NotHumanTarget Instantiated...");
            }
            manager = new NotHumanTarget(targetName, pixelArea);
        } else {
            throw new IllegalArgumentException(targetName
                    + " is not a supported target, check the properties file...");
        }

        return manager;
    }
}
